---
phase: 04-git-commit-linking
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/engine/decisions.ts
  - src/tools/decision-tools.ts
  - src/server.ts
  - test/decision-engine.test.ts
  - test/tools.test.ts
autonomous: true
requirements:
  - GITL-03
  - GITL-04

must_haves:
  truths:
    - "twining_why output includes commit_hashes for linked decisions"
    - "twining_commits returns decisions matching a given commit hash"
    - "twining_commits returns empty array for unlinked commits"
  artifacts:
    - path: "src/engine/decisions.ts"
      provides: "Updated why() returning commit_hashes, commits() method for commit-based query"
      contains: "commit_hashes"
    - path: "src/tools/decision-tools.ts"
      provides: "twining_commits tool registration"
      contains: "twining_commits"
  key_links:
    - from: "src/tools/decision-tools.ts"
      to: "src/engine/decisions.ts"
      via: "engine.getByCommitHash()"
      pattern: "engine\\.getByCommitHash"
    - from: "src/engine/decisions.ts"
      to: "src/storage/decision-store.ts"
      via: "decisionStore.getByCommitHash()"
      pattern: "decisionStore\\.getByCommitHash"
---

<objective>
Add commit hash visibility to decision queries and create the commit-based lookup tool. This completes bidirectional traceability: decisions reference commits (Plan 01) AND commits can be queried for decisions (this plan).

Purpose: Agents need to see commit hashes when asking "why was this done?" and need to query "what decisions drove this commit?" Both capabilities are essential for the git-to-decision traceability story.
Output: Updated `twining_why` output with commit_hashes, new `twining_commits` tool.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/04-git-commit-linking/04-01-SUMMARY.md
@src/engine/decisions.ts
@src/tools/decision-tools.ts
@src/server.ts
@test/decision-engine.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich twining_why output with commit hashes and add twining_commits tool</name>
  <files>
    src/engine/decisions.ts
    src/tools/decision-tools.ts
    test/decision-engine.test.ts
  </files>
  <action>
    1. In `src/engine/decisions.ts`, update the `why()` method:
       - The return type's `decisions` array items currently have: `id, summary, rationale, confidence, status, timestamp, alternatives_count`. Add `commit_hashes: string[]` to this shape.
       - In the mapping function, include `commit_hashes: d.commit_hashes ?? []` (the `?? []` handles any pre-existing decisions that were created before this feature and lack the field).

    2. In `src/tools/decision-tools.ts`, register new `twining_commits` tool:
       - Tool name: `"twining_commits"`
       - Description: "Query decisions by commit hash. Returns all decisions that were linked to a given commit, enabling traceability from code changes back to decision rationale."
       - inputSchema:
         - `commit_hash: z.string().describe("Git commit hash to look up")`
       - Handler: calls `engine.getByCommitHash(args.commit_hash)` (already implemented in Plan 01)
       - Returns the result via `toolResult(result)`
       - Error handling: same try/catch pattern as other tools

    3. In `test/decision-engine.test.ts`, add tests:
       - Test `why()` on a scope with a decision that has commit_hashes — verify the output includes commit_hashes array
       - Test `why()` on a scope with a decision that has no commit_hashes — verify commit_hashes is empty array (backward compatible)
       - Test `getByCommitHash()` returns decisions with full metadata shape (id, summary, domain, scope, confidence, timestamp, commit_hashes)
       - Test `getByCommitHash()` for hash linked to multiple decisions returns all of them
       - Test `getByCommitHash()` for unknown hash returns empty decisions array

    4. Verify that `twining_commits` is accessible via the MCP server by checking that `registerDecisionTools` in `decision-tools.ts` includes the new tool registration (it should, since we're adding it inside the same `registerDecisionTools` function that registers all other decision tools, no changes needed in `server.ts`).
  </action>
  <verify>Run `npx vitest run test/decision-engine.test.ts` — all tests pass. Run `npx vitest run` — full suite passes. Run `npx tsc --noEmit` — compiles cleanly.</verify>
  <done>twining_why output includes commit_hashes for each decision. twining_commits tool exists and returns decisions for a given commit hash. Backward compatibility maintained for decisions without commit_hashes. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npx vitest run test/decision-engine.test.ts` — all tests pass including new commit-related tests
2. `npx vitest run` — full test suite passes
3. `npx tsc --noEmit` — TypeScript compiles without errors
4. Manual verification: create a decision with commit_hash via twining_decide, call twining_why and verify commit_hashes appear, call twining_commits with the hash and verify decision returned
</verification>

<success_criteria>
- `twining_why` output includes `commit_hashes: string[]` for each decision in the results
- `twining_commits` tool registered and callable, returns decisions matching a commit hash
- Pre-existing decisions (without commit_hashes field) gracefully return empty array
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-commit-linking/04-02-SUMMARY.md`
</output>
