---
phase: 05-gsd-bridge-serena-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/planning-bridge.ts
  - src/engine/context-assembler.ts
  - src/utils/types.ts
  - test/planning-bridge.test.ts
  - test/context-assembler.test.ts
autonomous: true
requirements:
  - GSDB-01
  - GSDB-02
  - GSDB-04

must_haves:
  truths:
    - "twining_assemble output includes planning_state with current phase, progress, and blockers when .planning/ exists"
    - "twining_summarize output includes planning_state with phase, progress, and open requirements when .planning/ exists"
    - "Planning context is scored alongside blackboard/decisions in assemble — phase requirements and progress surface when task relates to planning"
    - "When .planning/ does not exist, assemble and summarize work exactly as before (no errors, no planning_state)"
  artifacts:
    - path: "src/engine/planning-bridge.ts"
      provides: "PlanningBridge class that reads .planning/ state"
      exports: ["PlanningBridge", "PlanningState"]
    - path: "src/engine/context-assembler.ts"
      provides: "Updated assemble() and summarize() integrating planning state"
    - path: "src/utils/types.ts"
      provides: "PlanningState interface, updated AssembledContext and SummarizeResult"
    - path: "test/planning-bridge.test.ts"
      provides: "Tests for PlanningBridge"
    - path: "test/context-assembler.test.ts"
      provides: "Updated tests for planning-aware assemble and summarize"
  key_links:
    - from: "src/engine/planning-bridge.ts"
      to: ".planning/STATE.md"
      via: "fs.readFileSync + regex parsing"
      pattern: "readPlanningState"
    - from: "src/engine/context-assembler.ts"
      to: "src/engine/planning-bridge.ts"
      via: "constructor injection"
      pattern: "planningBridge"
    - from: "src/server.ts"
      to: "src/engine/planning-bridge.ts"
      via: "instantiation and injection into ContextAssembler"
---

<objective>
Create a PlanningBridge that reads `.planning/` state and integrate it into context assembly and summarization.

Purpose: Enables Twining to surface GSD planning state (current phase, progress, blockers, open requirements) in `twining_assemble` and `twining_summarize` output so agents have full project context.

Output: PlanningBridge engine module, updated ContextAssembler with planning-aware assemble/summarize, updated types, tests.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/engine/context-assembler.ts
@src/utils/types.ts
@src/server.ts
@test/context-assembler.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlanningBridge engine module and update types</name>
  <files>
    src/engine/planning-bridge.ts
    src/utils/types.ts
    test/planning-bridge.test.ts
  </files>
  <action>
Create `src/engine/planning-bridge.ts` with a `PlanningBridge` class:

1. Constructor takes `projectRoot: string` (the project root, NOT the .twining dir).
2. Method `readPlanningState(): PlanningState | null`:
   - Check if `.planning/STATE.md` exists at projectRoot. If not, return null.
   - Parse STATE.md using regex/string parsing to extract:
     - `current_phase`: from the "Phase: N of M (name)" line under Current Position
     - `progress`: from the "Progress: [###...] NN%" line
     - `blockers`: from the Blockers/Concerns section (text between header and next section)
     - `pending_todos`: from the Pending Todos section
   - Also check if `.planning/ROADMAP.md` exists and parse:
     - `open_requirements`: scan for unchecked `- [ ]` lines under the current phase's Requirements section in REQUIREMENTS.md
   - Return a `PlanningState` object.
3. Method `isAvailable(): boolean` — returns true if `.planning/STATE.md` exists.

The parsing should be resilient: if a section is missing or malformed, use sensible defaults (empty strings/arrays). Never throw from readPlanningState — return null on any error.

Add to `src/utils/types.ts`:
```typescript
/** Planning state from .planning/ directory */
export interface PlanningState {
  current_phase: string;
  progress: string;
  blockers: string[];
  pending_todos: string[];
  open_requirements: string[];
}
```

Update `SummarizeResult` to include optional `planning_state?: PlanningState`.
Update `AssembledContext` to include optional `planning_state?: PlanningState`.

Write `test/planning-bridge.test.ts`:
- Test with a temp dir containing a mock STATE.md file (copy format from actual STATE.md)
- Test that it parses current_phase, progress, blockers correctly
- Test that it returns null when .planning/ doesn't exist
- Test resilience: malformed STATE.md returns partial data, not null/error
- Test that REQUIREMENTS.md open requirements are parsed when the file exists
  </action>
  <verify>
Run `npx vitest run test/planning-bridge.test.ts` — all tests pass.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
PlanningBridge correctly parses .planning/STATE.md and .planning/REQUIREMENTS.md into a PlanningState object. Returns null gracefully when files don't exist. All tests pass. Types updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate PlanningBridge into ContextAssembler and wire in server.ts</name>
  <files>
    src/engine/context-assembler.ts
    src/server.ts
    test/context-assembler.test.ts
  </files>
  <action>
Update `src/engine/context-assembler.ts`:

1. Add `planningBridge` as an optional constructor parameter (after graphEngine): `planningBridge?: PlanningBridge | null`. Store as `this.planningBridge = planningBridge ?? null`.

2. In `assemble()`:
   - After building the AssembledContext result object (before the return), call `this.planningBridge?.readPlanningState()`.
   - If planningState is not null:
     - Set `result.planning_state = planningState`
     - Add a synthetic scored item of type "finding" for planning context. Text: `"Planning: Phase ${planningState.current_phase}, Progress: ${planningState.progress}"`. Include blockers if any. Score it with recency=1.0 (always fresh), relevance=0.5 (moderate default), confidence=0.5. This ensures planning context competes for token budget alongside other items (GSDB-04).
     - The planning_state is always included in the result regardless of token budget (it's metadata, not a scored item consuming budget). The synthetic finding IS scored and may be cut by budget.
   - If null, don't add planning_state to result.

3. In `summarize()`:
   - After building the SummarizeResult, call `this.planningBridge?.readPlanningState()`.
   - If planningState is not null, set `result.planning_state = planningState`.
   - Append to `recent_activity_summary`: ` Current phase: ${planningState.current_phase}. Progress: ${planningState.progress}.`

Update `src/server.ts`:
1. Import PlanningBridge from `./engine/planning-bridge.js`.
2. After creating the `twiningDir`, create `const planningBridge = new PlanningBridge(projectRoot);`.
3. Pass `planningBridge` as the last argument to `new ContextAssembler(...)`.

Update `test/context-assembler.test.ts`:
- Add tests for assemble() when PlanningBridge returns state (mock it or create temp .planning/ dir)
- Add test for summarize() including planning_state
- Add test that assemble/summarize still work when PlanningBridge returns null (no .planning/ dir)
- Verify planning_state appears in assembled context when .planning/ exists
  </action>
  <verify>
Run `npx vitest run test/context-assembler.test.ts` — all tests pass including new planning-aware tests.
Run `npx vitest run test/planning-bridge.test.ts` — still passes.
Run `npx tsc --noEmit` — no type errors.
Run `npx vitest run` — full test suite passes (no regressions).
  </verify>
  <done>
ContextAssembler.assemble() includes planning_state when .planning/ exists and scores planning context alongside other items. ContextAssembler.summarize() includes planning_state and mentions current phase in activity summary. server.ts wires PlanningBridge to ContextAssembler. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — full test suite passes with no regressions
2. `npx tsc --noEmit` — no type errors
3. Manual verification: In a project with `.planning/STATE.md`, calling `twining_assemble` returns a response containing `planning_state` with `current_phase`, `progress`, etc.
4. Manual verification: In a project without `.planning/`, calling `twining_assemble` returns the same format as before (no `planning_state` field, no errors)
</verification>

<success_criteria>
- PlanningBridge reads .planning/STATE.md and .planning/REQUIREMENTS.md reliably
- assemble() output includes planning_state when .planning/ exists (GSDB-01, GSDB-04)
- summarize() output includes planning_state when .planning/ exists (GSDB-02)
- Planning context is scored alongside other items in assemble budget (GSDB-04)
- No regressions — existing tests pass, no errors when .planning/ is absent
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-bridge-serena-docs/05-01-SUMMARY.md`
</output>
