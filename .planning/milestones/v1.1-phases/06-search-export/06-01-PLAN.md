---
phase: 06-search-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/decisions.ts
  - src/tools/decision-tools.ts
  - src/engine/decisions.test.ts
  - src/tools/decision-tools.test.ts
autonomous: true
requirements:
  - SRCH-01
  - SRCH-02

must_haves:
  truths:
    - "Agent can search decisions by keyword across all scopes without specifying scope"
    - "Search results include relevance score and indicate fallback mode"
    - "Results can be filtered by domain, status, and confidence level"
  artifacts:
    - path: "src/engine/decisions.ts"
      provides: "searchDecisions() method on DecisionEngine"
      contains: "searchDecisions"
    - path: "src/tools/decision-tools.ts"
      provides: "twining_search_decisions MCP tool registration"
      contains: "twining_search_decisions"
  key_links:
    - from: "src/tools/decision-tools.ts"
      to: "src/engine/decisions.ts"
      via: "engine.searchDecisions() call"
      pattern: "engine\\.searchDecisions"
    - from: "src/engine/decisions.ts"
      to: "src/embeddings/search.ts"
      via: "SearchEngine.searchDecisions() for semantic/keyword search"
      pattern: "searchEngine\\.searchDecisions"
---

<objective>
Add `twining_search_decisions` tool that lets agents find decisions by keyword or semantic search across ALL scopes, with optional filters for domain, status, and confidence.

Purpose: Currently agents must know a scope to find decisions (via `twining_why`). This tool enables discovery — "find all decisions about authentication" works without knowing which scope auth decisions live under.

Output: New `searchDecisions()` engine method, `twining_search_decisions` MCP tool, and tests.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/engine/decisions.ts
@src/tools/decision-tools.ts
@src/embeddings/search.ts
@src/storage/decision-store.ts
@src/utils/types.ts
@src/utils/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add searchDecisions() to DecisionEngine</name>
  <files>src/engine/decisions.ts</files>
  <action>
Add a `searchDecisions()` method to `DecisionEngine`. This method:

1. Accepts parameters:
   - `query: string` (required) — the search text
   - `filters?: { domain?: string; status?: DecisionStatus; confidence?: DecisionConfidence }` — optional filters
   - `limit?: number` — max results (default 20)

2. Implementation:
   - Load ALL decisions from the index via `this.decisionStore.getIndex()`
   - Apply filters on the index entries BEFORE loading full decision files:
     - If `filters.domain` is set, keep only entries where `entry.domain === filters.domain`
     - If `filters.status` is set, keep only entries where `entry.status === filters.status`
     - If `filters.confidence` is set, keep only entries where `entry.confidence === filters.confidence`
   - Load full Decision objects for filtered entries (via `this.decisionStore.get(entry.id)`)
   - If `this.searchEngine` exists (it's a new constructor param — see below), call `this.searchEngine.searchDecisions(query, decisions, { limit })` and return the results mapped to a clean output format
   - If no searchEngine, fall back to manual keyword matching: for each decision, check if query terms appear in summary+rationale+context, score by match count, sort descending, take limit

3. Add `searchEngine` as an optional constructor parameter (after `projectRoot`). Store as `private readonly searchEngine: SearchEngine | null`. Import `SearchEngine` type from `../embeddings/search.js`.

4. Return type:
   ```typescript
   Promise<{
     results: Array<{
       id: string;
       summary: string;
       domain: string;
       scope: string;
       confidence: string;
       status: string;
       timestamp: string;
       relevance: number;
       commit_hashes: string[];
     }>;
     total_matched: number;
     fallback_mode: boolean;
   }>
   ```

5. The method should never throw — wrap search errors in try/catch and return empty results with an error message if needed. Follow the established pattern of graceful fallback.
  </action>
  <verify>Run `npx vitest run src/engine/decisions.test.ts` — existing tests still pass. Write a quick inline check that the new method exists on DecisionEngine by inspecting the compiled output or running a simple test.</verify>
  <done>DecisionEngine has a searchDecisions() method that loads all decisions, applies filters, delegates to SearchEngine for ranking, and returns scored results. Constructor accepts optional SearchEngine parameter.</done>
</task>

<task type="auto">
  <name>Task 2: Register twining_search_decisions tool and wire into server</name>
  <files>src/tools/decision-tools.ts, src/server.ts</files>
  <action>
1. In `src/tools/decision-tools.ts`:
   - Add a new `twining_search_decisions` tool registration after the existing `twining_link_commit` registration
   - Tool description: "Search decisions across all scopes by keyword or semantic similarity. Returns ranked results without requiring a specific scope. Supports filtering by domain, status, and confidence level."
   - Input schema (using zod):
     - `query: z.string().describe("Search query — keywords or natural language description of what you're looking for")`
     - `domain: z.string().optional().describe("Filter by decision domain (e.g., 'architecture', 'implementation')")`
     - `status: z.enum(["active", "provisional", "superseded", "overridden"]).optional().describe("Filter by decision status")`
     - `confidence: z.enum(["high", "medium", "low"]).optional().describe("Filter by confidence level")`
     - `limit: z.number().optional().describe("Maximum results to return (default: 20)")`
   - Handler: build filters object from optional args, call `engine.searchDecisions(args.query, filters, args.limit)`, wrap in `toolResult()`. Follow the existing try/catch pattern with TwiningError handling.

2. In `src/server.ts`:
   - Import `SearchEngine` (already imported)
   - Pass `searchEngine` as the new final argument to `DecisionEngine` constructor:
     ```typescript
     const decisionEngine = new DecisionEngine(
       decisionStore,
       blackboardEngine,
       embedder,
       indexManager,
       projectRoot,
       searchEngine,  // NEW: for twining_search_decisions
     );
     ```
  </action>
  <verify>Run `npx vitest run` to ensure all tests pass. Run `npx tsc --noEmit` to verify no type errors. Grep for "twining_search_decisions" in the tools file to confirm registration.</verify>
  <done>twining_search_decisions tool is registered with query, domain, status, confidence, and limit parameters. Server passes SearchEngine to DecisionEngine constructor. TypeScript compiles clean.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for searchDecisions</name>
  <files>src/engine/decisions.test.ts</files>
  <action>
Add tests to the existing decisions test file (or create one if it doesn't exist). Use vitest with temp directories following the project's test patterns.

Test cases:
1. **Search finds decisions by keyword** — Create 3 decisions with different summaries. Search for a keyword in one summary. Verify only the matching decision is returned with relevance > 0.
2. **Search with domain filter** — Create decisions in domains "architecture" and "implementation". Search with domain="architecture" filter. Verify only architecture decisions are returned.
3. **Search with status filter** — Create active and overridden decisions. Search with status="active". Verify only active decisions appear.
4. **Search with confidence filter** — Create high and low confidence decisions. Search with confidence="high". Verify only high confidence decisions appear.
5. **Empty query returns empty results** — Search with empty string. Should return empty results, not error.
6. **No matches returns empty** — Search for gibberish. Should return `{ results: [], total_matched: 0, fallback_mode: true }`.

Since SearchEngine requires embedder/indexManager (heavy ONNX), test without SearchEngine (null) to exercise the keyword fallback path. This is the standard pattern — SearchEngine is optional.
  </action>
  <verify>Run `npx vitest run src/engine/decisions.test.ts` — all new tests pass.</verify>
  <done>6 test cases for searchDecisions covering keyword search, domain/status/confidence filters, edge cases. All pass using keyword fallback (no ONNX).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles clean
2. `npx vitest run` — all tests pass
3. `grep -r "twining_search_decisions" src/` confirms tool registration
4. The tool accepts query + optional filters and returns ranked decision results
</verification>

<success_criteria>
- twining_search_decisions tool is registered and callable
- Searching by keyword finds matching decisions across all scopes
- Domain, status, and confidence filters narrow results correctly
- Results include relevance scores and fallback_mode indicator
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-search-export/06-01-SUMMARY.md`
</output>
