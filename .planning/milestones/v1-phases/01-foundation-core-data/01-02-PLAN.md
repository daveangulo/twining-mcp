---
phase: 01-foundation-core-data
plan: 02
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src/engine/blackboard.ts
  - src/engine/decisions.ts
  - src/tools/blackboard-tools.ts
  - src/tools/decision-tools.ts
  - src/tools/lifecycle-tools.ts
  - src/server.ts
  - src/index.ts
  - test/blackboard-engine.test.ts
  - test/decision-engine.test.ts
  - test/tools.test.ts
  - test/integration.test.ts
autonomous: true
requirements:
  - BLKB-01
  - BLKB-02
  - BLKB-04
  - DCSN-01
  - DCSN-02
  - MCPI-01
  - MCPI-02
  - MCPI-03
  - FOUND-04

must_haves:
  truths:
    - "Agent can post a blackboard entry with type/summary/tags/scope and get back an ID"
    - "Agent can read blackboard entries filtered by type, tags, scope, or recency"
    - "Agent can record a decision with rationale, alternatives, and confidence"
    - "Agent can retrieve all decisions affecting a given scope via twining_why"
    - "All tool calls return structured JSON responses including for invalid inputs"
    - "Server connects via stdio and registers all Phase 1 tools"
    - "Server auto-creates .twining/ directory on first tool call"
  artifacts:
    - path: "src/engine/blackboard.ts"
      provides: "Blackboard business logic: validate input, generate ID, delegate to store"
      exports: ["BlackboardEngine"]
    - path: "src/engine/decisions.ts"
      provides: "Decision business logic: validate input, conflict detection stub, cross-post to blackboard"
      exports: ["DecisionEngine"]
    - path: "src/tools/blackboard-tools.ts"
      provides: "MCP tool handlers for twining_post, twining_read, twining_recent"
      exports: ["registerBlackboardTools"]
    - path: "src/tools/decision-tools.ts"
      provides: "MCP tool handlers for twining_decide, twining_why"
      exports: ["registerDecisionTools"]
    - path: "src/tools/lifecycle-tools.ts"
      provides: "MCP tool handler for twining_status (basic)"
      exports: ["registerLifecycleTools"]
    - path: "src/server.ts"
      provides: "McpServer creation with all tool registrations"
      exports: ["createServer"]
    - path: "src/index.ts"
      provides: "Entry point: create server, connect stdio transport"
  key_links:
    - from: "src/engine/blackboard.ts"
      to: "src/storage/blackboard-store.ts"
      via: "BlackboardStore for data persistence"
      pattern: "BlackboardStore"
    - from: "src/engine/decisions.ts"
      to: "src/storage/decision-store.ts"
      via: "DecisionStore for data persistence"
      pattern: "DecisionStore"
    - from: "src/engine/decisions.ts"
      to: "src/engine/blackboard.ts"
      via: "Cross-posts decision entry to blackboard on decide"
      pattern: "blackboard.*post|BlackboardEngine"
    - from: "src/tools/blackboard-tools.ts"
      to: "src/engine/blackboard.ts"
      via: "Tool handlers call engine methods"
      pattern: "BlackboardEngine"
    - from: "src/tools/decision-tools.ts"
      to: "src/engine/decisions.ts"
      via: "Tool handlers call engine methods"
      pattern: "DecisionEngine"
    - from: "src/server.ts"
      to: "src/tools/blackboard-tools.ts"
      via: "Registers all tools on McpServer"
      pattern: "registerBlackboardTools|registerDecisionTools|registerLifecycleTools"
    - from: "src/index.ts"
      to: "src/server.ts"
      via: "Creates server and connects transport"
      pattern: "createServer|StdioServerTransport"
---

<objective>
Build the engine layer (blackboard business logic, decision business logic), all Phase 1 MCP tool handlers with Zod input schemas, server wiring, and stdio entry point. Connect everything end-to-end so `npx twining-mcp` starts a working MCP server.

Purpose: Complete Phase 1 by wiring storage layer (from Plan 01) through engine logic to MCP tool surface. This delivers the core thesis: agents can post to a shared blackboard, record decisions with rationale, and query both.

Output: Working MCP server that handles twining_post, twining_read, twining_recent, twining_decide, twining_why, and twining_status over stdio.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@TWINING-DESIGN-SPEC.md
@CLAUDE.md
@.planning/phases/01-foundation-core-data/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Engine layer — blackboard and decision business logic</name>
  <files>
    src/engine/blackboard.ts
    src/engine/decisions.ts
    test/blackboard-engine.test.ts
    test/decision-engine.test.ts
  </files>
  <action>
**src/engine/blackboard.ts:**
Class `BlackboardEngine` constructed with `store: BlackboardStore`.

Methods:
- `post(input: { entry_type: string, summary: string, detail?: string, tags?: string[], scope?: string, relates_to?: string[], agent_id?: string }): Promise<{ id: string, timestamp: string }>` — validates entry_type against ENTRY_TYPES constant (from types.ts), validates summary max 200 chars, sets defaults (scope="project", agent_id="main", tags=[], detail=""), delegates to `store.append()`. Returns `{ id, timestamp }`. On invalid input, throw `TwiningError` with code `INVALID_INPUT`.
- `read(filters?: { entry_types?: string[], tags?: string[], scope?: string, since?: string, limit?: number }): Promise<{ entries: BlackboardEntry[], total_count: number }>` — delegates to `store.read()`. Default limit is 50.
- `recent(n?: number, entry_types?: string[]): Promise<{ entries: BlackboardEntry[] }>` — delegates to `store.recent()`. Returns `{ entries }`.

**src/engine/decisions.ts:**
Class `DecisionEngine` constructed with `decisionStore: DecisionStore, blackboardEngine: BlackboardEngine`.

Methods:
- `decide(input: { domain: string, scope: string, summary: string, context: string, rationale: string, constraints?: string[], alternatives?: Array<{ option: string, pros?: string[], cons?: string[], reason_rejected: string }>, depends_on?: string[], supersedes?: string, confidence?: "high" | "medium" | "low", reversible?: boolean, affected_files?: string[], affected_symbols?: string[], agent_id?: string }): Promise<{ id: string, timestamp: string }>` — validates required fields (domain, scope, summary, context, rationale). Sets defaults (confidence="medium", reversible=true, agent_id="main", constraints=[], alternatives=[], depends_on=[], affected_files=[], affected_symbols=[]). If `supersedes` is set, call `decisionStore.updateStatus(supersedes, "superseded")`. Creates decision via `decisionStore.create()`. Cross-posts a "decision" entry to blackboard via `blackboardEngine.post({ entry_type: "decision", summary: decision.summary, detail: decision.rationale, tags: [decision.domain], scope: decision.scope, agent_id: decision.agent_id })`. Returns `{ id, timestamp }`.
- `why(scope: string): Promise<{ decisions: Array<{ id: string, summary: string, rationale: string, confidence: string, status: string, timestamp: string, alternatives_count: number }>, active_count: number, provisional_count: number }>` — calls `decisionStore.getByScope(scope)`. Maps to response format, counts active and provisional.

**test/blackboard-engine.test.ts:**
Use temp dir. Test:
- Post valid entry returns id and timestamp
- Post with invalid entry_type throws TwiningError with INVALID_INPUT
- Post with summary >200 chars throws TwiningError
- Read with no filters returns entries
- Read with filters delegates correctly
- Recent returns last N entries
- Defaults are applied correctly (scope, agent_id)

**test/decision-engine.test.ts:**
Use temp dir. Test:
- Decide with valid input creates decision and cross-posts to blackboard
- Decide with missing required field throws TwiningError
- Decide with supersedes updates old decision to "superseded"
- Why returns decisions matching scope with correct counts
- Why returns empty for non-matching scope
- Defaults applied correctly (confidence, reversible)
  </action>
  <verify>
Run `npx vitest run test/blackboard-engine.test.ts test/decision-engine.test.ts` — all tests pass.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
Engine layer validates input, applies defaults, delegates to stores, and cross-posts decisions to blackboard. Invalid inputs produce TwiningError with appropriate codes. Tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: MCP tool handlers, server wiring, and entry point</name>
  <files>
    src/tools/blackboard-tools.ts
    src/tools/decision-tools.ts
    src/tools/lifecycle-tools.ts
    src/server.ts
    src/index.ts
    test/tools.test.ts
    test/integration.test.ts
  </files>
  <action>
**src/tools/blackboard-tools.ts:**
Export `registerBlackboardTools(server: McpServer, engine: BlackboardEngine): void`.

Register three tools using `server.registerTool()`:

1. `twining_post` — input schema uses Zod: `entry_type` as `z.enum(ENTRY_TYPES)`, `summary` as `z.string().max(200)`, `detail` as `z.string().optional()`, `tags` as `z.array(z.string()).optional()`, `scope` as `z.string().optional()`, `relates_to` as `z.array(z.string()).optional()`, `agent_id` as `z.string().optional()`. Handler calls `engine.post()`, wraps result with `toolResult()`. On error, returns `toolError()` with code.

2. `twining_read` — input schema: `entry_types` as `z.array(z.string()).optional()`, `tags` as `z.array(z.string()).optional()`, `scope` as `z.string().optional()`, `since` as `z.string().optional()`, `limit` as `z.number().optional()`. Handler calls `engine.read()`, returns `toolResult()`.

3. `twining_recent` — input schema: `n` as `z.number().optional()`, `entry_types` as `z.array(z.string()).optional()`. Handler calls `engine.recent()`, returns `toolResult()`.

**src/tools/decision-tools.ts:**
Export `registerDecisionTools(server: McpServer, engine: DecisionEngine): void`.

Register two tools:

1. `twining_decide` — input schema matching design spec section 4.2 `twining_decide` input, using Zod types. All optional fields have `.optional()`. `alternatives` uses `z.array(z.object({ option: z.string(), pros: z.array(z.string()).optional(), cons: z.array(z.string()).optional(), reason_rejected: z.string() })).optional()`. Handler calls `engine.decide()`, returns `toolResult()`.

2. `twining_why` — input schema: `scope` as `z.string()`. Handler calls `engine.why()`, returns `toolResult()`.

**src/tools/lifecycle-tools.ts:**
Export `registerLifecycleTools(server: McpServer, twiningDir: string): void`.

Register one tool:

1. `twining_status` — no input required (empty schema or omit inputSchema). Handler reads blackboard and decision counts from the stores, returns `toolResult()` with: `{ project: basename(projectRoot), blackboard_entries: count, active_decisions: count, provisional_decisions: count, graph_entities: 0, graph_relations: 0, last_activity: timestamp, needs_archiving: boolean }`.

**src/server.ts:**
Export `createServer(projectRoot: string): McpServer`.
- Calls `ensureInitialized(projectRoot)` to get twiningDir
- Loads config via `loadConfig(twiningDir)`
- Creates BlackboardStore, DecisionStore
- Creates BlackboardEngine, DecisionEngine
- Creates McpServer with `name: "twining-mcp"`, `version` from package.json (or hardcode "1.0.0")
- Calls all register functions: `registerBlackboardTools`, `registerDecisionTools`, `registerLifecycleTools`
- Returns the server

**src/index.ts:**
Entry point. Parse `--project` arg from process.argv (default to `process.cwd()`).
- Call `createServer(projectRoot)`
- Create `new StdioServerTransport()`
- `await server.connect(transport)`
- NEVER use console.log — only console.error for fatal errors
- Add top-level `main().catch(err => { console.error("Fatal:", err); process.exit(1); })`

Add `#!/usr/bin/env node` shebang at top of index.ts for npx execution.

**test/tools.test.ts:**
Test tool handler functions directly (not through MCP transport). Create engines with temp dir, then test:
- twining_post handler returns toolResult format on success
- twining_post handler returns toolError format on invalid input
- twining_read handler returns entries
- twining_recent handler returns entries
- twining_decide handler returns id and timestamp
- twining_why handler returns decisions

**test/integration.test.ts:**
End-to-end integration test:
- Create a temp directory as project root
- Call `createServer(projectRoot)` — verify .twining/ is created
- Using the engines directly (since we can't easily test stdio):
  1. Post 3 blackboard entries (finding, warning, need)
  2. Read all entries — expect 3
  3. Read filtered by type "warning" — expect 1
  4. Read recent 2 — expect 2
  5. Create a decision with alternatives
  6. Query twining_why for the decision's scope — expect 1 decision
  7. Verify the decision also appears as a blackboard entry (cross-post)
  8. Call status — verify counts match
  </action>
  <verify>
Run `npx vitest run test/tools.test.ts test/integration.test.ts` — all tests pass.
Run `npx vitest run` — FULL test suite passes (all tests from Plan 01 + Plan 02).
Run `npx tsc --noEmit` — no type errors.
Run `npx tsc` — compiles to dist/ successfully.
Verify `dist/index.js` exists and has shebang line.
  </verify>
  <done>
All Phase 1 MCP tools registered with Zod schemas. Server creates .twining/ on init. Stdio transport connected. Full integration test proves end-to-end flow: post -> read -> decide -> why -> status. Project builds to dist/ and is executable via npx.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npx vitest run` — all tests pass (full suite including Plan 01 tests)
3. `npx tsc` — compiles to dist/ successfully
4. Integration test proves full flow: post blackboard entry, read it back with filters, decide with rationale, query why, get status
5. No console.log calls in any src/ file (only console.error)
6. All tool handlers return structured JSON (never throw)
7. Invalid inputs produce structured error responses (not crashes)
</verification>

<success_criteria>
- twining_post accepts all 10 entry types with Zod validation
- twining_read filters by type, tags, scope, since, and limit
- twining_recent returns the last N entries
- twining_decide creates a decision with full rationale and cross-posts to blackboard
- twining_why returns all decisions matching a scope with active/provisional counts
- twining_status returns blackboard and decision counts
- All tool handlers catch errors and return structured responses
- Server auto-creates .twining/ on first use
- Entry point uses StdioServerTransport (no console.log)
- Full integration test verifies the complete workflow
- `npx tsc` compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-data/01-02-SUMMARY.md`
</output>
