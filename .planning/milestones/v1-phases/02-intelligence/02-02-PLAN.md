---
phase: 02-intelligence
plan: 02
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src/engine/context-assembler.ts
  - src/tools/context-tools.ts
  - src/server.ts
  - test/context-assembler.test.ts
  - test/context-tools.test.ts
autonomous: true
requirements:
  - CTXA-01
  - CTXA-02
  - CTXA-03
  - CTXA-04

must_haves:
  truths:
    - "Agent can request assembled context for a task+scope and receive relevant decisions, blackboard entries, and summaries within a token budget"
    - "Agent can get a high-level summary of project or scope state"
    - "Agent can see what changed since a given timestamp"
    - "Context assembly uses weighted scoring: recency, relevance, decision confidence, warning boost"
  artifacts:
    - path: "src/engine/context-assembler.ts"
      provides: "Context assembly engine with weighted scoring and token budget management"
      exports: ["ContextAssembler"]
    - path: "src/tools/context-tools.ts"
      provides: "MCP tool handlers for twining_assemble, twining_summarize, twining_what_changed"
      exports: ["registerContextTools"]
    - path: "test/context-assembler.test.ts"
      provides: "Context assembler unit tests with fixture data"
    - path: "test/context-tools.test.ts"
      provides: "Context tools integration tests"
  key_links:
    - from: "src/engine/context-assembler.ts"
      to: "src/embeddings/search.ts"
      via: "SearchEngine for semantic relevance scoring"
      pattern: "searchEngine"
    - from: "src/engine/context-assembler.ts"
      to: "src/storage/blackboard-store.ts"
      via: "Read blackboard entries for assembly"
      pattern: "blackboardStore.*read"
    - from: "src/engine/context-assembler.ts"
      to: "src/storage/decision-store.ts"
      via: "Read decisions for assembly"
      pattern: "decisionStore"
    - from: "src/tools/context-tools.ts"
      to: "src/engine/context-assembler.ts"
      via: "Tool handlers delegate to assembler"
      pattern: "contextAssembler"
    - from: "src/server.ts"
      to: "src/tools/context-tools.ts"
      via: "Register context tools on MCP server"
      pattern: "registerContextTools"
---

<objective>
Build the context assembly engine and MCP tools: token-budgeted context assembly with weighted multi-signal scoring, project/scope summarization, and change reporting. Wire everything into the MCP server as twining_assemble, twining_summarize, and twining_what_changed tools.

Purpose: Give agents the ability to get tailored, relevant context packages for any task within a token budget (CTXA-01), understand project state at a glance (CTXA-02), and see what changed since they last checked (CTXA-03). This completes the Intelligence phase.
Output: `src/engine/context-assembler.ts`, `src/tools/context-tools.ts`; updated `src/server.ts` with new tool registrations.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@TWINING-DESIGN-SPEC.md
@src/utils/types.ts
@src/utils/tokens.ts
@src/config.ts
@src/storage/blackboard-store.ts
@src/storage/decision-store.ts
@src/engine/blackboard.ts
@src/engine/decisions.ts
@src/embeddings/search.ts
@src/server.ts
@.planning/phases/02-intelligence/02-01-SUMMARY.md
@.planning/phases/02-intelligence/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Context assembler engine</name>
  <files>
    src/engine/context-assembler.ts
    test/context-assembler.test.ts
  </files>
  <action>
    **Create `src/engine/context-assembler.ts`** — Context assembly with weighted scoring and token budgets:

    The assembler needs access to: BlackboardStore, DecisionStore, SearchEngine (from Plan 01), and config (for weights and default budget).

    **Constructor:** `ContextAssembler(blackboardStore, decisionStore, searchEngine, config: TwiningConfig)`

    **Method: `assemble(task: string, scope: string, maxTokens?: number): Promise<AssembledContext>`**
    Implements the algorithm from spec section 4.3 (twining_assemble):

    1. **Retrieve scope-matched decisions:** Use `decisionStore.getByScope(scope)` to get all active decisions affecting the scope (file prefix match + symbol match). Filter to `status === 'active' || status === 'provisional'`.

    2. **Retrieve semantically relevant decisions:** If searchEngine is available, use `searchEngine.searchDecisions(task, allDecisions)` to find decisions semantically similar to the task description. Merge with scope-matched decisions (union by ID, keep highest relevance score).

    3. **Retrieve scope-matched blackboard entries:** Use `blackboardStore.read({ scope })` to get entries in scope. Separate by type:
       - `open_needs`: entries with `entry_type === 'need'`
       - `active_warnings`: entries with `entry_type === 'warning'`
       - `recent_questions`: entries with `entry_type === 'question'`
       - `recent_findings`: entries with `entry_type === 'finding'`

    4. **Retrieve semantically relevant findings:** If searchEngine available, search for findings similar to the task description.

    5. **Score each item** using weighted combination from config:
       ```
       score = recency * w_recency + relevance * w_relevance + confidence * w_confidence + warning_boost * w_warning
       ```
       Where:
       - `recency`: Exponential decay based on age. Use `Math.exp(-age_hours / HALF_LIFE)` where HALF_LIFE = 168 (one week). Normalized to [0, 1].
       - `relevance`: Cosine similarity score from search engine (0-1). For scope-only matches without semantic score, use 0.5 as a default relevance.
       - `confidence`: For decisions: high=1.0, medium=0.6, low=0.3. For non-decisions: 0.5 (neutral).
       - `warning_boost`: 1.0 for warnings, 0.0 for everything else.
       - Weights from `config.context_assembly.priority_weights` (recency: 0.3, relevance: 0.4, decision_confidence: 0.2, warning_boost: 0.1).

    6. **Fill token budget** in priority order:
       - Use `estimateTokens(text)` from `src/utils/tokens.ts` (text.length / 4)
       - Start with highest-scored items
       - For decisions: estimate tokens for `summary + rationale + confidence + affected_files`
       - For blackboard entries: estimate tokens for `summary + detail`
       - Stop adding items when budget is exhausted
       - Always include at least warnings and needs even if low-scored (safety margin: reserve 10% of budget for warnings)

    7. **Build and return `AssembledContext`** matching the interface in `src/utils/types.ts`:
       - `assembled_at`: current ISO timestamp
       - `task`, `scope`: from input
       - `token_estimate`: actual tokens used
       - `active_decisions`: mapped from scored decisions (id, summary, rationale, confidence, affected_files)
       - `open_needs`, `recent_findings`, `active_warnings`, `recent_questions`: mapped from scored entries
       - `related_entities`: empty array for now (graph is Phase 3)

    **Method: `summarize(scope?: string): Promise<SummarizeResult>`**
    Implements spec section 4.3 (twining_summarize):
    - Count active decisions, provisional decisions, open needs, active warnings, unanswered questions in scope
    - Generate `recent_activity_summary` string: "In the last 24 hours: X decisions made, Y findings posted, Z warnings raised." Use last 24h of entries.
    - Return: `{ scope, active_decisions, provisional_decisions, open_needs, active_warnings, unanswered_questions, recent_activity_summary }`

    **Method: `whatChanged(since: string, scope?: string): Promise<WhatChangedResult>`**
    Implements spec section 4.3 (twining_what_changed):
    - Filter blackboard entries with `timestamp >= since` and scope match
    - Filter decisions with `timestamp >= since` and scope match
    - Find overridden decisions: `status === 'overridden'` with timestamp >= since
    - Find reconsidered decisions: `status === 'provisional'` with timestamp >= since (those that were changed to provisional)
    - Return: `{ new_decisions, new_entries, overridden_decisions, reconsidered_decisions }`

    **Define result interfaces** (add to types.ts or define locally):
    ```typescript
    interface SummarizeResult {
      scope: string;
      active_decisions: number;
      provisional_decisions: number;
      open_needs: number;
      active_warnings: number;
      unanswered_questions: number;
      recent_activity_summary: string;
    }

    interface WhatChangedResult {
      new_decisions: { id: string; summary: string }[];
      new_entries: { id: string; entry_type: string; summary: string }[];
      overridden_decisions: { id: string; summary: string; reason: string }[];
      reconsidered_decisions: { id: string; summary: string }[];
    }
    ```

    **Tests (`test/context-assembler.test.ts`):**
    Use temp directories with pre-populated fixture data.

    - Test `assemble()` returns correct structure matching AssembledContext interface
    - Test token budget is respected (create enough entries to exceed budget, verify total_token_estimate <= maxTokens)
    - Test scoring: create entries with different ages, verify more recent entries score higher
    - Test scoring: create entries with warnings, verify they get priority boost
    - Test scope filtering: entries outside scope are excluded
    - Test with null/unavailable search engine (keyword fallback path)
    - Test `summarize()` returns correct counts for a populated store
    - Test `summarize()` with scope filter narrows results
    - Test `whatChanged()` filters by timestamp correctly
    - Test `whatChanged()` identifies overridden and reconsidered decisions
    - Test empty store returns empty/zero results (not errors)
  </action>
  <verify>
    ```bash
    npm test -- --run test/context-assembler.test.ts
    npx tsc --noEmit
    ```
    All tests pass. TypeScript compiles without errors.
  </verify>
  <done>
    ContextAssembler.assemble() produces token-budgeted context packages with weighted scoring. summarize() returns project state counts and activity narrative. whatChanged() reports changes since a timestamp. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Context tools and server wiring</name>
  <files>
    src/tools/context-tools.ts
    src/server.ts
    src/utils/types.ts
    test/context-tools.test.ts
  </files>
  <action>
    **Update `src/utils/types.ts`** — Add result interfaces if not already present:
    - `SummarizeResult` interface matching spec section 4.3 twining_summarize return
    - `WhatChangedResult` interface matching spec section 4.3 twining_what_changed return

    **Create `src/tools/context-tools.ts`** — MCP tool handlers:

    Export function `registerContextTools(server: McpServer, contextAssembler: ContextAssembler)`:

    **Tool: `twining_assemble`** (spec section 4.3):
    - Zod schema:
      ```typescript
      {
        task: z.string().describe("Description of what the agent is about to do"),
        scope: z.string().describe("File path, module, or area of codebase"),
        max_tokens: z.number().optional().describe("Token budget (default: from config)")
      }
      ```
    - Handler: delegates to `contextAssembler.assemble(task, scope, max_tokens)`
    - Wrap in try/catch, return structured error on failure (TwiningError pattern)
    - Return: AssembledContext object

    **Tool: `twining_summarize`** (spec section 4.3):
    - Zod schema:
      ```typescript
      {
        scope: z.string().optional().describe("Optional scope filter (default: 'project')")
      }
      ```
    - Handler: delegates to `contextAssembler.summarize(scope)`
    - Return: SummarizeResult object

    **Tool: `twining_what_changed`** (spec section 4.3):
    - Zod schema:
      ```typescript
      {
        since: z.string().describe("ISO 8601 timestamp"),
        scope: z.string().optional().describe("Optional scope filter")
      }
      ```
    - Handler: delegates to `contextAssembler.whatChanged(since, scope)`
    - Return: WhatChangedResult object

    All handlers follow the same error handling pattern as existing tools in `blackboard-tools.ts` and `decision-tools.ts`:
    ```typescript
    try {
      const result = await contextAssembler.method(args);
      return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
    } catch (error) {
      if (error instanceof TwiningError) {
        return { content: [{ type: "text", text: JSON.stringify({ error: true, message: error.message, code: error.code }) }] };
      }
      return { content: [{ type: "text", text: JSON.stringify({ error: true, message: String(error), code: "INTERNAL_ERROR" }) }] };
    }
    ```

    **Update `src/server.ts`:**
    - Import `ContextAssembler` from `src/engine/context-assembler.ts`
    - Import `registerContextTools` from `src/tools/context-tools.ts`
    - After creating searchEngine (from Plan 01): create `contextAssembler = new ContextAssembler(blackboardStore, decisionStore, searchEngine, config)`
    - Load config from `.twining/config.yml` (use existing config loading if available, or load it)
    - Register context tools: `registerContextTools(server, contextAssembler)`

    **Tests (`test/context-tools.test.ts`):**
    - Test `twining_assemble` tool returns valid AssembledContext JSON
    - Test `twining_summarize` tool returns valid SummarizeResult JSON
    - Test `twining_what_changed` tool returns valid WhatChangedResult JSON
    - Test error handling: invalid input returns structured error, not crash
    - Test default values: scope defaults to "project", max_tokens defaults to config value
  </action>
  <verify>
    ```bash
    npm test -- --run test/context-tools.test.ts
    npm test -- --run
    npx tsc --noEmit
    npm run build
    ```
    All tests pass (existing + new). TypeScript compiles. Build to dist/ succeeds.
  </verify>
  <done>
    Three new MCP tools registered: twining_assemble, twining_summarize, twining_what_changed. All have proper Zod schemas matching the design spec. Server.ts wires ContextAssembler with all dependencies. Full test suite passes. Project builds to dist/.
  </done>
</task>

</tasks>

<verification>
1. `npm test` — all tests pass (existing Phase 1 + new Phase 2)
2. `npx tsc --noEmit` — TypeScript compiles without errors
3. `npm run build` — builds to dist/ successfully
4. Verify three new tools are registered: twining_assemble, twining_summarize, twining_what_changed
5. Verify context assembly respects token budget
6. Verify weighted scoring produces sensible rankings (warnings boosted, recent items preferred)
7. Verify summarize returns accurate counts
8. Verify what_changed correctly filters by timestamp
</verification>

<success_criteria>
- All CTXA-* requirements addressed
- Context assembly within token budget (CTXA-01): maxTokens respected
- Summarize works (CTXA-02): counts + narrative
- What changed works (CTXA-03): filtered by timestamp and scope
- Weighted scoring (CTXA-04): recency, relevance, confidence, warning boost all factor in
- All tests pass, TypeScript compiles, builds to dist/
- Server registers all three new tools with proper Zod schemas
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence/02-02-SUMMARY.md`
</output>
