---
phase: 09-search-and-filter
plan: 02
type: execute
wave: 2
depends_on:
  - 09-01
files_modified:
  - src/dashboard/public/index.html
  - src/dashboard/public/style.css
  - src/dashboard/public/app.js
autonomous: true
requirements:
  - SRCH-01
  - SRCH-02
  - SRCH-04
  - SRCH-05

must_haves:
  truths:
    - "User can type in a search bar and see unified results from blackboard, decisions, and graph in a Search tab"
    - "User can filter search results by type, status, scope, and date range"
    - "User can click ULID references in detail panels to navigate to the referenced item in its correct tab"
    - "User can set a global scope filter in the header that constrains data in all tabs"
    - "Search is debounced at 300ms to avoid excessive API calls"
  artifacts:
    - path: "src/dashboard/public/index.html"
      provides: "Search bar, filter controls, Search tab, global scope input"
      contains: "tab-search"
    - path: "src/dashboard/public/style.css"
      provides: "Styles for search UI, filters, clickable IDs, scope filter"
      contains: "search-bar"
    - path: "src/dashboard/public/app.js"
      provides: "Search logic, navigateToId, global scope filter, debounce"
      contains: "navigateToId"
  key_links:
    - from: "src/dashboard/public/app.js"
      to: "/api/search"
      via: "fetch call to search endpoint with query params"
      pattern: "fetch.*api/search"
    - from: "src/dashboard/public/app.js"
      to: "switchTab"
      via: "navigateToId calls switchTab to jump to correct tab for clicked ID"
      pattern: "navigateToId.*switchTab"
    - from: "src/dashboard/public/app.js"
      to: "renderBlackboard"
      via: "applyGlobalScope filters data before sort/paginate in all render functions"
      pattern: "applyGlobalScope"
---

<objective>
Build the frontend search experience: search bar with debounce, Search tab with results table, filter controls, clickable ULID references in detail panels, and a global scope filter that constrains all dashboard views.

Purpose: This delivers the user-facing UI for SRCH-01 (free-text search), SRCH-02 (faceted filtering), SRCH-04 (clickable ID navigation), and SRCH-05 (global scope filter). Consumes the /api/search endpoint from Plan 01.

Output: Modified index.html, style.css, and app.js with complete search and filter functionality.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/09-search-and-filter/09-01-SUMMARY.md
@.planning/phases/08-observability-dashboard/08-02-SUMMARY.md

@src/dashboard/public/index.html
@src/dashboard/public/style.css
@src/dashboard/public/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search UI elements to HTML and CSS</name>
  <files>src/dashboard/public/index.html, src/dashboard/public/style.css</files>
  <action>
**index.html changes:**

1. **Global scope filter in header.** Add a scope input inside the `<header>` element, after the `<h1>` and before `.header-status`:
   ```html
   <div class="global-scope-filter">
     <label for="global-scope">Scope:</label>
     <input type="text" id="global-scope" placeholder="Filter by scope (e.g., src/auth/)..." />
     <span id="scope-indicator" class="scope-indicator" style="display:none"></span>
   </div>
   ```

2. **Search bar between nav and main.** Add a search section after the `<nav class="tabs">` and before `<main>`:
   ```html
   <div class="search-bar">
     <input type="text" id="search-input" placeholder="Search across all data..." />
     <div class="search-filters">
       <select id="filter-types" multiple title="Filter by type">
         <option value="blackboard" selected>Blackboard</option>
         <option value="decisions" selected>Decisions</option>
         <option value="entities" selected>Entities</option>
       </select>
       <select id="filter-status" title="Filter by status">
         <option value="">Any status</option>
         <option value="active">Active</option>
         <option value="provisional">Provisional</option>
         <option value="superseded">Superseded</option>
         <option value="overridden">Overridden</option>
       </select>
       <input type="date" id="filter-since" title="From date" />
       <input type="date" id="filter-until" title="Until date" />
       <button id="search-btn" title="Search">Search</button>
       <button id="search-clear-btn" title="Clear search">Clear</button>
     </div>
   </div>
   ```

3. **Search tab button.** Add a fifth tab button after "Graph":
   ```html
   <button class="tab-btn" data-tab="search">Search</button>
   ```

4. **Search tab content.** Add inside `<main>`, after the Graph tab content and before `</main>`:
   ```html
   <!-- Search Tab -->
   <div class="tab-content" id="tab-search" style="display:none">
     <div id="search-status-bar"></div>
     <div class="content-area">
       <div class="list-panel">
         <table class="data-table" id="search-table">
           <thead>
             <tr>
               <th>Type</th>
               <th>Summary / Name</th>
               <th>Scope</th>
               <th>Relevance</th>
               <th>Timestamp</th>
             </tr>
           </thead>
           <tbody></tbody>
         </table>
         <div class="pagination" id="search-pagination"></div>
       </div>
       <div class="detail-panel" id="search-detail">
         <p class="placeholder">Click a search result to view details</p>
       </div>
     </div>
   </div>
   ```

**style.css changes:**

Add styles for the new UI elements at the end of the file:

1. **Search bar styles:**
   ```css
   .search-bar {
     display: flex;
     flex-wrap: wrap;
     gap: 0.5rem;
     padding: 0.75rem 1.5rem;
     background: #f8f9fa;
     border-bottom: 1px solid #e0e0e0;
     align-items: center;
   }
   .search-bar input[type="text"] {
     flex: 1;
     min-width: 200px;
     padding: 0.5rem 0.75rem;
     border: 1px solid #ccc;
     border-radius: 4px;
     font-size: 0.95rem;
   }
   .search-filters {
     display: flex;
     flex-wrap: wrap;
     gap: 0.4rem;
     align-items: center;
   }
   .search-filters select, .search-filters input[type="date"] {
     padding: 0.4rem;
     border: 1px solid #ccc;
     border-radius: 4px;
     font-size: 0.85rem;
   }
   .search-filters button {
     padding: 0.4rem 0.75rem;
     border: 1px solid #ccc;
     border-radius: 4px;
     background: #fff;
     cursor: pointer;
     font-size: 0.85rem;
   }
   .search-filters button:hover {
     background: #e8e8e8;
   }
   #search-btn {
     background: #4a90d9;
     color: #fff;
     border-color: #4a90d9;
   }
   #search-btn:hover {
     background: #3a7bc8;
   }
   ```

2. **Global scope filter styles:**
   ```css
   .global-scope-filter {
     display: flex;
     align-items: center;
     gap: 0.5rem;
   }
   .global-scope-filter label {
     font-size: 0.85rem;
     color: #666;
     white-space: nowrap;
   }
   .global-scope-filter input {
     width: 220px;
     padding: 0.35rem 0.6rem;
     border: 1px solid #ccc;
     border-radius: 4px;
     font-size: 0.85rem;
   }
   .global-scope-filter input.scope-active {
     border-color: #4a90d9;
     box-shadow: 0 0 0 2px rgba(74, 144, 217, 0.2);
   }
   .scope-indicator {
     font-size: 0.8rem;
     color: #4a90d9;
     white-space: nowrap;
   }
   ```

3. **Search status bar and clickable ID styles:**
   ```css
   #search-status-bar {
     padding: 0.5rem 1rem;
     font-size: 0.85rem;
     color: #666;
   }
   .search-fallback-notice {
     color: #a0522d;
     font-size: 0.85rem;
     font-style: italic;
     padding: 0.25rem 1rem;
   }
   .clickable-id {
     color: #4a90d9;
     text-decoration: underline;
     cursor: pointer;
   }
   .clickable-id:hover {
     color: #2a6ab9;
   }
   ```

4. **Header layout update** — the header currently uses flexbox. Ensure the global scope filter fits alongside the title and status indicators:
   ```css
   header {
     /* Existing styles probably include display:flex. Add: */
     flex-wrap: wrap;
     gap: 1rem;
   }
   ```
   Check the existing header styles and extend rather than overwrite. The scope filter should sit between the h1 and the status dots on wider screens, wrapping below on narrow screens.

IMPORTANT: All new HTML uses textContent patterns established in Phase 8. No innerHTML for user data.
  </action>
  <verify>Open the dashboard HTML file in a browser (or verify with `npx tsc --noEmit` that no TS issues exist in modified files). Visual check: search bar visible between tabs and content, Search tab clickable, global scope input in header, filter controls next to search input.</verify>
  <done>The HTML has a search bar with input and filter controls, a "Search" tab button and content section with results table and detail panel, and a global scope filter input in the header. CSS styles make all new elements visually consistent with the Phase 8 dashboard design.</done>
</task>

<task type="auto">
  <name>Task 2: Add search logic, clickable IDs, and global scope filter to app.js</name>
  <files>src/dashboard/public/app.js</files>
  <action>
Extend app.js with the following additions. Follow established patterns: use `var` (not let/const), `el()` helper, `clearElement()`, textContent for all user data, no innerHTML.

**1. State additions.** Add to the `state` object:
```javascript
search: { results: [], sortKey: "relevance", sortDir: "desc", page: 1, pageSize: 25, selectedId: null, query: "", fallback_mode: true },
globalScope: ""
```

**2. Debounce utility.** Add near the top helpers:
```javascript
function debounce(fn, delay) {
  var timer = null;
  return function() {
    var args = arguments;
    var ctx = this;
    if (timer) clearTimeout(timer);
    timer = setTimeout(function() { fn.apply(ctx, args); timer = null; }, delay);
  };
}
```

**3. Global scope filter logic.** Add:
```javascript
function applyGlobalScope(data, scopeField) {
  if (!state.globalScope) return data;
  var gs = state.globalScope;
  return data.filter(function(item) {
    var itemScope = item[scopeField || "scope"] || "";
    // For graph entities, check properties.file or properties.scope as fallback
    if (!itemScope && item.properties) {
      itemScope = item.properties.file || item.properties.scope || "";
    }
    return itemScope.startsWith(gs) || gs.startsWith(itemScope);
  });
}
```
Then modify the three existing render functions (`renderBlackboard`, `renderDecisions`, `renderGraph`) to apply `applyGlobalScope` before sorting. In each, after getting `ts.data`, add:
```javascript
var scoped = applyGlobalScope(ts.data, "scope");
var sorted = sortData(scoped, ts.sortKey, ts.sortDir);
```
(Replace the current `var sorted = sortData(ts.data, ...)` line.)

Wire up the global scope input with a debounced handler:
```javascript
var globalScopeInput = document.getElementById("global-scope");
if (globalScopeInput) {
  var debouncedScope = debounce(function() {
    state.globalScope = globalScopeInput.value.trim();
    // Visual indicator
    if (state.globalScope) {
      globalScopeInput.classList.add("scope-active");
      var indicator = document.getElementById("scope-indicator");
      if (indicator) { indicator.style.display = "inline"; indicator.textContent = "Filtered: " + state.globalScope; }
    } else {
      globalScopeInput.classList.remove("scope-active");
      var indicator2 = document.getElementById("scope-indicator");
      if (indicator2) indicator2.style.display = "none";
    }
    // Reset pagination, re-render active tab
    state.blackboard.page = 1;
    state.decisions.page = 1;
    state.graph.page = 1;
    refreshData();
  }, 300);
  globalScopeInput.addEventListener("input", debouncedScope);
}
```

**4. Search functionality.** Add `performSearch` and `fetchSearch`:
```javascript
function buildSearchUrl() {
  var q = state.search.query;
  if (!q) return null;
  var params = "q=" + encodeURIComponent(q);

  // Type filter
  var typesSelect = document.getElementById("filter-types");
  if (typesSelect) {
    var selectedTypes = [];
    for (var i = 0; i < typesSelect.options.length; i++) {
      if (typesSelect.options[i].selected) selectedTypes.push(typesSelect.options[i].value);
    }
    if (selectedTypes.length > 0 && selectedTypes.length < 3) {
      params += "&types=" + selectedTypes.join(",");
    }
  }

  // Status filter
  var statusSelect = document.getElementById("filter-status");
  if (statusSelect && statusSelect.value) params += "&status=" + encodeURIComponent(statusSelect.value);

  // Scope (uses global scope if set)
  if (state.globalScope) params += "&scope=" + encodeURIComponent(state.globalScope);

  // Date filters
  var sinceInput = document.getElementById("filter-since");
  if (sinceInput && sinceInput.value) params += "&since=" + sinceInput.value + "T00:00:00Z";
  var untilInput = document.getElementById("filter-until");
  if (untilInput && untilInput.value) params += "&until=" + untilInput.value + "T23:59:59Z";

  return "/api/search?" + params;
}

function fetchSearch() {
  var url = buildSearchUrl();
  if (!url) {
    state.search.results = [];
    renderSearchResults();
    return;
  }

  fetch(url)
    .then(function(res) {
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    })
    .then(function(data) {
      state.search.results = data.results || [];
      state.search.fallback_mode = data.fallback_mode !== false;
      state.search.page = 1;
      state.connected = true;
      updateConnectionIndicator();
      renderSearchResults();
    })
    .catch(function() {
      state.connected = false;
      updateConnectionIndicator();
    });
}

function performSearch() {
  var input = document.getElementById("search-input");
  state.search.query = input ? input.value.trim() : "";
  if (!state.search.query) {
    state.search.results = [];
    renderSearchResults();
    return;
  }
  // Auto-switch to search tab
  switchTab("search");
  fetchSearch();
}
```

**5. Search results rendering.** Add `renderSearchResults`:
```javascript
function renderSearchResults() {
  var ts = state.search;
  var tbody = document.querySelector("#search-table tbody");
  if (!tbody) return;
  clearElement(tbody);

  var sorted = sortData(ts.results, ts.sortKey, ts.sortDir);
  var page = paginate(sorted, ts.page, ts.pageSize);

  for (var i = 0; i < page.length; i++) {
    var result = page[i];
    var tr = el("tr");
    tr.setAttribute("data-id", result.id || "");
    if (ts.selectedId && result.id === ts.selectedId) tr.classList.add("selected");

    // Type badge
    var tdType = el("td");
    tdType.appendChild(createBadge(result.type));
    tr.appendChild(tdType);

    // Summary/Name
    var tdSummary = el("td", null, truncate(result.summary || result.name || "--", 80));
    tr.appendChild(tdSummary);

    // Scope
    var tdScope = el("td", null, result.scope || "--");
    tr.appendChild(tdScope);

    // Relevance
    var relPct = Math.round((result.relevance || 0) * 100);
    var tdRel = el("td", null, relPct + "%");
    tr.appendChild(tdRel);

    // Timestamp
    var tdTime = el("td", null, formatTimestamp(result.timestamp));
    tr.appendChild(tdTime);

    // Click to navigate to source
    (function(r) {
      tr.addEventListener("click", function() {
        ts.selectedId = r.id;
        renderSearchResults();
        renderSearchDetail(r);
      });
    })(result);

    tbody.appendChild(tr);
  }

  renderPagination("search-pagination", sorted.length, ts, renderSearchResults);

  // Status bar
  var statusBar = document.getElementById("search-status-bar");
  if (statusBar) {
    clearElement(statusBar);
    if (ts.query) {
      var msg = ts.results.length + " results for \"" + ts.query + "\"";
      if (ts.fallback_mode) msg += " (keyword search)";
      else msg += " (semantic search)";
      statusBar.appendChild(el("span", null, msg));
    }
  }
}

function renderSearchDetail(result) {
  var panel = document.getElementById("search-detail");
  if (!panel) return;
  clearElement(panel);

  panel.appendChild(el("h3", null, (result.type || "Item") + " Details"));

  var fields = [
    { label: "ID", value: result.id },
    { label: "Type", value: result.type },
    { label: "Summary", value: result.summary || result.name },
    { label: "Scope", value: result.scope },
    { label: "Relevance", value: result.relevance != null ? Math.round(result.relevance * 100) + "%" : null },
    { label: "Timestamp", value: formatTimestamp(result.timestamp) },
    { label: "Status", value: result.status },
    { label: "Domain", value: result.domain },
    { label: "Confidence", value: result.confidence },
    { label: "Entry Type", value: result.entry_type },
    { label: "Entity Type", value: result.entity_type }
  ];

  for (var i = 0; i < fields.length; i++) {
    var f = fields[i];
    if (f.value === undefined || f.value === null) continue;
    var div = el("div", "detail-field");
    div.appendChild(el("div", "detail-label", f.label));
    // Use clickable ID rendering for ID field
    if (f.label === "ID") {
      var valDiv = el("div", "detail-value");
      renderIdValue(valDiv, String(f.value));
      div.appendChild(valDiv);
    } else {
      div.appendChild(el("div", "detail-value", String(f.value)));
    }
    panel.appendChild(div);
  }

  // "Go to item" button
  if (result.id) {
    var goBtn = el("button", null, "Go to " + result.type + " tab");
    goBtn.style.marginTop = "1rem";
    goBtn.addEventListener("click", function() { navigateToId(result.id); });
    panel.appendChild(goBtn);
  }
}
```

**6. Clickable ID navigation (SRCH-04).** Add ULID detection and navigateToId:
```javascript
var ULID_PATTERN = /^[0-9A-HJKMNP-TV-Z]{26}$/i;

function renderIdValue(container, value) {
  if (ULID_PATTERN.test(value)) {
    var link = el("span", "clickable-id", value);
    link.addEventListener("click", function(e) {
      e.stopPropagation();
      navigateToId(value);
    });
    container.appendChild(link);
  } else {
    container.textContent = value;
  }
}

function renderIdList(container, ids) {
  if (!ids || !ids.length) { container.textContent = "--"; return; }
  for (var i = 0; i < ids.length; i++) {
    if (i > 0) container.appendChild(document.createTextNode(", "));
    renderIdValue(container, ids[i]);
  }
}

function navigateToId(id) {
  // Check blackboard
  for (var i = 0; i < state.blackboard.data.length; i++) {
    if (state.blackboard.data[i].id === id) {
      switchTab("blackboard");
      state.blackboard.selectedId = id;
      renderBlackboard();
      renderBlackboardDetail(state.blackboard.data[i]);
      return;
    }
  }
  // Check decisions
  for (var j = 0; j < state.decisions.data.length; j++) {
    if (state.decisions.data[j].id === id) {
      switchTab("decisions");
      state.decisions.selectedId = id;
      renderDecisions();
      fetchDecisionDetail(id);
      return;
    }
  }
  // Check graph entities
  for (var k = 0; k < state.graph.data.length; k++) {
    if (state.graph.data[k].id === id) {
      switchTab("graph");
      state.graph.selectedId = id;
      renderGraph();
      renderGraphDetail(state.graph.data[k]);
      return;
    }
  }
  // Not found -- data may not be loaded yet. Try loading all data first.
  var statusBar = document.getElementById("search-status-bar");
  if (statusBar) {
    clearElement(statusBar);
    statusBar.appendChild(el("span", null, "ID not found in loaded data: " + id));
  }
}
```

**7. Update existing detail renderers for clickable IDs.** In `renderBlackboardDetail`, change the "Relates To" field to use `renderIdList` instead of plain textContent. Specifically, replace the relates_to line in the fields array with a custom rendering block after the fields loop:
- Remove relates_to from the fields array
- After the fields loop, add a custom block that calls `renderIdList` for the relates_to array

Similarly, in `renderDecisionDetail`, for fields like `depends_on`, `supersedes`, and any other ULID fields, use `renderIdValue` or `renderIdList`.

In `renderGraphDetail`, for `source` and `target` relation fields, use `renderIdValue`.

**8. Wire up event handlers.** In the `DOMContentLoaded` or init section:
- Search input: debounced performSearch on "input" event
- Search button: performSearch on click
- Clear button: clear search input, reset search state, switch to stats tab
- Enter key in search input: immediate performSearch (bypass debounce)
- Tab button click handler: extend existing switchTab handler to handle "search" tab
- In `refreshData()`: add `else if (tab === "search" && state.search.query) fetchSearch();`
- In `handleSort`: add search tab sort support

**9. Update switchTab.** When switching to a data tab (blackboard/decisions/graph), if the data is not yet loaded (empty array), trigger a fetch. This ensures navigateToId can work even when navigating to a tab whose data hasn't been loaded yet. Add to switchTab:
```javascript
if (tabName === "blackboard" && state.blackboard.data.length === 0) fetchBlackboard();
if (tabName === "decisions" && state.decisions.data.length === 0) fetchDecisions();
if (tabName === "graph" && state.graph.data.length === 0) fetchGraph();
```

IMPORTANT: All user-provided text must use textContent, never innerHTML. Follow the established `el()` pattern. Use `var` throughout (no let/const — matches Phase 8 convention).
  </action>
  <verify>Build the project (`npm run build`) to ensure static assets copy correctly. Open the dashboard in a browser. Verify: (1) search bar visible, (2) typing triggers debounced search, (3) Search tab shows results, (4) clicking result navigates to source tab, (5) global scope filter reduces displayed items in all tabs, (6) clickable IDs in detail panels navigate correctly.</verify>
  <done>The dashboard has a fully functional search experience: search bar with debounce and filters, Search tab with merged results, clickable ULID IDs in all detail panels, and a global scope filter that constrains all views. All user content rendered via textContent.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Dashboard loads in browser without JS errors
3. Search bar appears between tabs and content area
4. Typing "test" in search bar and pressing Enter switches to Search tab with results
5. Filter controls (type, status, date range) narrow results
6. Clicking a search result shows its detail; "Go to tab" button navigates correctly
7. ULID references in blackboard detail (relates_to) and decision detail are clickable links
8. Setting global scope filter to a prefix reduces items shown in all tabs
9. Clearing global scope filter restores full data in all tabs
10. Polling still works with visibility-aware lifecycle
</verification>

<success_criteria>
- Search bar with 300ms debounce triggers /api/search endpoint
- Search tab displays merged results with type badges and relevance percentages
- Filter controls (types, status, since, until) modify search query params
- navigateToId() finds items across all loaded data and switches to correct tab
- ULID-pattern strings in detail panels are rendered as clickable links
- Global scope input in header filters all tab renders via applyGlobalScope
- All user content uses textContent (no innerHTML for user data)
- Existing tabs (Stats, Blackboard, Decisions, Graph) continue working
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-and-filter/09-02-SUMMARY.md`
</output>
