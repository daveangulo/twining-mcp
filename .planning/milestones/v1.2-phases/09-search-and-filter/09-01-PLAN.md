---
phase: 09-search-and-filter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/api-routes.ts
  - test/dashboard/api-routes.test.ts
autonomous: true
requirements:
  - SRCH-01
  - SRCH-02
  - SRCH-03

must_haves:
  truths:
    - "GET /api/search?q=text returns unified results from blackboard, decisions, and graph"
    - "Results include type badge, relevance score, and metadata for each item"
    - "Query params types, status, scope, tags, since, until filter results server-side"
    - "Response includes fallback_mode flag indicating keyword vs semantic search"
    - "Existing /api/* endpoints continue working unchanged"
  artifacts:
    - path: "src/dashboard/api-routes.ts"
      provides: "/api/search endpoint with engine-based search orchestration"
      contains: "searchDecisions"
    - path: "test/dashboard/api-routes.test.ts"
      provides: "Search endpoint test coverage"
      contains: "/api/search"
  key_links:
    - from: "src/dashboard/api-routes.ts"
      to: "src/engine/blackboard.ts"
      via: "BlackboardEngine.query() for semantic/keyword blackboard search"
      pattern: "blackboardEngine\\.query"
    - from: "src/dashboard/api-routes.ts"
      to: "src/engine/decisions.ts"
      via: "DecisionEngine.searchDecisions() for decision search with filters"
      pattern: "decisionEngine\\.searchDecisions"
    - from: "src/dashboard/api-routes.ts"
      to: "src/engine/graph.ts"
      via: "GraphEngine.query() for entity substring search"
      pattern: "graphEngine\\.query"
---

<objective>
Add a unified `/api/search` endpoint to the dashboard that orchestrates BlackboardEngine.query(), DecisionEngine.searchDecisions(), and GraphEngine.query() to return merged, relevance-ranked results across all data types.

Purpose: The search endpoint is the backbone for SRCH-01 (cross-type search), SRCH-02 (faceted filtering), and SRCH-03 (semantic search). The frontend (Plan 02) consumes this single endpoint.

Output: Modified api-routes.ts with /api/search endpoint, updated tests.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/08-observability-dashboard/08-01-SUMMARY.md

@src/dashboard/api-routes.ts
@src/dashboard/http-server.ts
@src/engine/blackboard.ts
@src/engine/decisions.ts
@src/engine/graph.ts
@src/embeddings/embedder.ts
@src/embeddings/search.ts
@src/embeddings/index-manager.ts
@test/dashboard/api-routes.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add /api/search endpoint with engine-based search orchestration</name>
  <files>src/dashboard/api-routes.ts</files>
  <action>
Modify `createApiHandler` in `api-routes.ts` to:

1. **Create engine instances in the closure** (alongside existing store instances). Add imports for `BlackboardEngine`, `DecisionEngine`, `GraphEngine`, `Embedder`, `IndexManager`, `SearchEngine`. Create them in the closure:
   ```typescript
   // Existing stores (keep as-is for other endpoints)
   const blackboardStore = new BlackboardStore(twiningDir);
   const decisionStore = new DecisionStore(twiningDir);
   const graphStore = new GraphStore(twiningDir);

   // Engine layer for search (new)
   const embedder = Embedder.getInstance(twiningDir);
   const indexManager = new IndexManager(twiningDir);
   const searchEngine = new SearchEngine(embedder, indexManager);
   const blackboardEngine = new BlackboardEngine(blackboardStore, embedder, indexManager, searchEngine);
   const decisionEngine = new DecisionEngine(decisionStore, blackboardEngine, embedder, indexManager, projectRoot, searchEngine);
   const graphEngine = new GraphEngine(graphStore);
   ```
   The `Embedder.getInstance()` singleton ensures the expensive ONNX model loads at most once even if the MCP server also creates an Embedder for the same twiningDir.

2. **Add the `/api/search` route** before the existing routes. Match URLs starting with `/api/search`. Parse query parameters using `new URL(url, "http://localhost")`:
   - `q` (string): search query text (required, return empty results if missing)
   - `types` (comma-separated): which types to search — "blackboard", "decisions", "entities" (default: all three)
   - `scope` (string): scope prefix filter
   - `status` (string): filter decisions by status (active, provisional, superseded, overridden)
   - `domain` (string): filter decisions by domain
   - `confidence` (string): filter decisions by confidence (high, medium, low)
   - `tags` (comma-separated): filter blackboard entries by tags
   - `since` (ISO 8601): only entries/decisions after this timestamp
   - `until` (ISO 8601): only entries/decisions before this timestamp
   - `limit` (number, default 20): max results per type

3. **Orchestrate searches across types.** For each requested type:
   - **blackboard**: Call `blackboardEngine.query(q, { entry_types: undefined, limit })`. Map results to unified shape: `{ type: "blackboard", id, summary, scope, timestamp, entry_type, relevance }`. If `scope` param set, post-filter by scope prefix match. If `tags` param set, pass as query option or post-filter. If `since`/`until` set, post-filter by timestamp comparison.
   - **decisions**: Call `decisionEngine.searchDecisions(q, { domain, status, confidence }, limit)`. Map to unified shape: `{ type: "decision", id, summary, scope, domain, status, confidence, timestamp, relevance }`. If `scope` set, post-filter. If `since`/`until` set, post-filter.
   - **entities**: Call `graphEngine.query(q, undefined, limit)`. Map to unified shape: `{ type: "entity", id, name, entity_type, properties, relevance: 0.5 }`. Graph entities get a fixed 0.5 relevance since GraphEngine has no relevance scoring.

4. **Sort merged results** by relevance descending, then timestamp descending as tiebreaker.

5. **Return JSON response:**
   ```json
   {
     "query": "...",
     "results": [...],
     "total": N,
     "fallback_mode": boolean
   }
   ```
   `fallback_mode` is true if blackboard query returned fallback_mode=true (or if no blackboard search was done). This tells the frontend whether semantic or keyword search was used.

6. **Handle uninitialized state:** If .twining/ doesn't exist, return `{ query, results: [], total: 0, fallback_mode: true }`.

7. **URL matching:** Use `url.startsWith("/api/search")` (not exact match) to capture query params. The existing Phase 8 pattern uses exact URL matching for other endpoints; /api/search needs query params so use startsWith and parse with new URL(). Make sure this route check comes before the `/api/status` check in the handler to avoid conflicts. The URL `/api/search` won't conflict with existing routes since none start with `/api/search`.

IMPORTANT: Keep all existing endpoints working exactly as they are. The engine instances are only used by the new /api/search endpoint. Existing endpoints continue using the raw stores. Do NOT use console.log — only console.error for errors (MCP stdout constraint).
  </action>
  <verify>Run `npx vitest run test/dashboard/api-routes.test.ts` — all existing tests pass (no regressions). Run `npx tsc --noEmit` — no type errors.</verify>
  <done>The /api/search endpoint exists in api-routes.ts, creates engine instances in the closure, orchestrates all three search methods, merges and sorts results, and returns the unified response shape with fallback_mode.</done>
</task>

<task type="auto">
  <name>Task 2: Add search endpoint tests</name>
  <files>test/dashboard/api-routes.test.ts</files>
  <action>
Add a new `describe("GET /api/search", ...)` block to the existing test file. The test project setup (`createTestProject`) already writes blackboard entries, decision index, and graph entities to the temp .twining/ directory, so searches will have data to match against.

Add these test cases:

1. **Returns empty results when no query** — `GET /api/search` (no `q` param) → 200 with `{ results: [], total: 0 }`.

2. **Returns blackboard results for matching query** — `GET /api/search?q=<term>` where term matches a known blackboard entry summary → 200 with at least one result of `type: "blackboard"`.

3. **Returns decision results for matching query** — `GET /api/search?q=<term>` matching a known decision summary → results include `type: "decision"`.

4. **Returns entity results for matching query** — `GET /api/search?q=<term>` matching a known graph entity name → results include `type: "entity"` with `relevance: 0.5`.

5. **Filters by types param** — `GET /api/search?q=<term>&types=blackboard` → only blackboard results, no decisions or entities.

6. **Includes fallback_mode in response** — verify the response has a `fallback_mode` boolean field.

7. **Returns empty for uninitialized project** — create a test server with a project root that has no .twining/ dir → `GET /api/search?q=test` returns `{ results: [], total: 0, fallback_mode: true }`.

8. **Filters by scope** — `GET /api/search?q=<term>&scope=<scope>` → only results matching the scope prefix.

9. **Filters by status** — `GET /api/search?q=<term>&status=active` → only decision results with active status.

10. **Results are sorted by relevance descending** — verify that results array is ordered by relevance highest first.

Use the existing `httpGet` helper and `createTestProject` setup patterns. For the uninitialized test, create a separate temp dir without .twining/. Start a test server for the search tests similar to the existing test setup.

NOTE: The search tests may return keyword-mode results (fallback_mode: true) since ONNX embeddings won't be loaded in the test environment. This is expected and correct — the test verifies the API contract, not the embedding quality. The keyword fallback in BlackboardEngine.query() requires a SearchEngine instance, which will use keywordSearch when ONNX is unavailable.

For the test data, check what `createTestProject` already writes and use matching terms. If existing test data doesn't have good search terms, add a few entries with distinctive words (e.g., "authentication", "refactoring") to the test setup.
  </action>
  <verify>Run `npx vitest run test/dashboard/api-routes.test.ts` — all tests pass including the new search tests. No test should take more than 10 seconds.</verify>
  <done>The search endpoint has comprehensive test coverage: empty query, per-type results, type filtering, scope filtering, status filtering, relevance ordering, fallback_mode presence, and uninitialized state handling.</done>
</task>

</tasks>

<verification>
1. `npx vitest run test/dashboard/api-routes.test.ts` — all tests pass (existing + new)
2. `npx tsc --noEmit` — no TypeScript errors
3. All existing /api/* endpoints return same responses as before (verified by existing tests passing)
4. /api/search?q=test returns a valid JSON response with results array, total count, and fallback_mode
</verification>

<success_criteria>
- /api/search endpoint orchestrates BlackboardEngine.query(), DecisionEngine.searchDecisions(), and GraphEngine.query()
- Query params support: q, types, scope, status, domain, confidence, tags, since, until, limit
- Results merged and sorted by relevance descending
- fallback_mode flag indicates keyword vs semantic search
- All existing endpoints unaffected (test suite passes)
- 8+ new test cases covering search behavior
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-and-filter/09-01-SUMMARY.md`
</output>
