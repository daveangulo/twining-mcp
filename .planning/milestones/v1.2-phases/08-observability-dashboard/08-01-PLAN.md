---
phase: 08-observability-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/api-routes.ts
  - src/dashboard/http-server.ts
  - test/dashboard/api-routes.test.ts
autonomous: true
requirements: [OBS-01, OBS-02, OBS-03, OBS-04, OBS-05]

must_haves:
  truths:
    - "GET /api/status returns JSON with blackboard_entries, active_decisions, provisional_decisions, graph_entities, graph_relations, last_activity"
    - "GET /api/blackboard returns JSON with entries array and total_count"
    - "GET /api/decisions returns JSON with decisions array (index entries)"
    - "GET /api/decisions/:id returns full decision object with rationale, alternatives, context"
    - "GET /api/graph returns JSON with entities and relations arrays"
    - "All API endpoints return 200 with Content-Type application/json"
    - "API endpoints return empty arrays and initialized:false when .twining/ does not exist"
  artifacts:
    - path: "src/dashboard/api-routes.ts"
      provides: "API route handler factory and all 5 endpoint implementations"
      exports: ["createApiHandler"]
    - path: "test/dashboard/api-routes.test.ts"
      provides: "Tests for all API endpoints"
      min_lines: 50
  key_links:
    - from: "src/dashboard/http-server.ts"
      to: "src/dashboard/api-routes.ts"
      via: "createApiHandler called in handleRequest, API handler invoked before static file fallback"
      pattern: "createApiHandler"
    - from: "src/dashboard/api-routes.ts"
      to: "src/storage/blackboard-store.ts"
      via: "BlackboardStore instantiated from twiningDir for read access"
      pattern: "new BlackboardStore"
    - from: "src/dashboard/api-routes.ts"
      to: "src/storage/decision-store.ts"
      via: "DecisionStore instantiated from twiningDir for read access"
      pattern: "new DecisionStore"
    - from: "src/dashboard/api-routes.ts"
      to: "src/storage/graph-store.ts"
      via: "GraphStore instantiated from twiningDir for read access"
      pattern: "new GraphStore"
---

<objective>
Create the data API layer for the Twining dashboard -- 5 JSON endpoints that expose blackboard entries, decisions, graph entities, and operational status to the frontend.

Purpose: The frontend (Plan 02) needs JSON APIs to render Twining state. This plan creates all server-side data endpoints and wires them into the existing HTTP server routing.

Output: `src/dashboard/api-routes.ts` with `createApiHandler()` factory, updated `http-server.ts` routing, comprehensive test suite.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-observability-dashboard/08-RESEARCH.md
@.planning/phases/07-http-server-foundation/07-01-SUMMARY.md

Key existing code:
@src/dashboard/http-server.ts (handleRequest function to extend with API routing)
@src/dashboard/dashboard-config.ts (DashboardConfig interface)
@src/storage/blackboard-store.ts (BlackboardStore: read(), recent() methods)
@src/storage/decision-store.ts (DecisionStore: getIndex(), get(id) methods)
@src/storage/graph-store.ts (GraphStore: getEntities(), getRelations() methods)
@src/utils/types.ts (BlackboardEntry, Decision, DecisionIndexEntry, Entity, Relation types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API routes module and wire into HTTP server</name>
  <files>src/dashboard/api-routes.ts, src/dashboard/http-server.ts</files>
  <action>
Create `src/dashboard/api-routes.ts` with a `createApiHandler(projectRoot: string)` factory function that returns an async request handler `(req, res) => Promise<boolean>`. The handler returns `true` if it handled the request, `false` if the URL didn't match any API route (so the caller falls through to static file serving).

**Store initialization:** Create BlackboardStore, DecisionStore, and GraphStore instances ONCE in the factory closure (not per-request). Compute `twiningDir = path.join(projectRoot, ".twining")`.

**Uninitialized state handling:** Before calling any store method, check if twiningDir exists using `fs.existsSync(twiningDir)`. If missing, return `{ initialized: false, ...empty_defaults }` with appropriate empty arrays/zeros for each endpoint. Do NOT call `ensureInitialized()` from the dashboard -- let MCP handle that.

**5 endpoints to implement:**

1. `GET /api/status` -- Return JSON: `{ initialized, blackboard_entries, active_decisions, provisional_decisions, graph_entities, graph_relations, last_activity }`. Mirror the logic from `twining_status` in lifecycle-tools.ts: read blackboard count, filter decision index for active/provisional counts, count entities and relations, compute last_activity from most recent blackboard entry and most recent decision timestamp.

2. `GET /api/blackboard` -- Return JSON: `{ initialized, entries, total_count }`. Call `blackboardStore.read()` to get all entries. Return entries array and total_count.

3. `GET /api/decisions` -- Return JSON: `{ initialized, decisions, total_count }`. Call `decisionStore.getIndex()` to get lightweight index entries (NOT full decision objects). Return as `decisions` array with count.

4. `GET /api/decisions/:id` -- Parse the ID from the URL path (match `/api/decisions/` prefix, extract remainder). Call `decisionStore.get(id)`. If found, return the full decision object. If not found, return 404 with `{ error: "Decision not found" }`.

5. `GET /api/graph` -- Return JSON: `{ initialized, entities, relations, entity_count, relation_count }`. Call `graphStore.getEntities()` and `graphStore.getRelations()`.

**Response helper:** Create a private `sendJSON(res, data, statusCode?)` function that sets Content-Type to `application/json; charset=utf-8`, Cache-Control to `no-cache`, and writes the JSON body.

**Error handling:** Wrap each endpoint in try/catch. On error, return 500 with `{ error: "Internal server error" }`. Log error to console.error (never console.log -- dashboard uses stderr only).

**Wire into http-server.ts:** Modify `handleRequest()` to accept `projectRoot` as a parameter (in addition to `publicDir`). Inside handleRequest, call `createApiHandler(projectRoot)` to get the API handler. In the returned request handler, call the API handler FIRST. If it returns true, the request was handled. If false, fall through to the existing /api/health check and then static file serving. Update `startDashboard()` to pass projectRoot to handleRequest (it already has projectRoot as a parameter).

**URL matching:** Use simple string comparison: `url === "/api/status"`, `url === "/api/blackboard"`, `url === "/api/decisions"`, `url === "/api/graph"`, and `url.startsWith("/api/decisions/")` for the detail endpoint. The URL variable comes from `req.url` which is already available.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation.
Run `npm test` to verify all existing tests still pass.
  </verify>
  <done>
api-routes.ts exports createApiHandler. http-server.ts calls it and routes API requests before static files. TypeScript compiles clean. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for all API endpoints</name>
  <files>test/dashboard/api-routes.test.ts</files>
  <action>
Create `test/dashboard/api-routes.test.ts` with vitest tests covering all 5 API endpoints. Use the same temp directory pattern as `test/dashboard/http-server.test.ts` -- create a temp dir, set up `.twining/` structure with test data, and make HTTP requests against a test server.

**Test setup:** For each test group, create a temp directory with `.twining/` containing:
- `blackboard.jsonl` with 2-3 test entries (JSONL format matching BlackboardEntry)
- `decisions/` directory with `index.jsonl` and 1-2 decision JSON files
- `graph/` directory with `entities.jsonl` and `relations.jsonl`

Use the actual store format that BlackboardStore, DecisionStore, and GraphStore expect.

**Start the HTTP server** using the `startDashboard` export or by directly invoking `http.createServer` with `handleRequest(publicDir, projectRoot)` on port 0 (OS-assigned). Get the actual port from `server.address()`.

**Test cases:**

1. `/api/status` -- verify response has all 6 fields, counts match test data
2. `/api/blackboard` -- verify entries array length matches, entries have expected fields (id, timestamp, summary, entry_type)
3. `/api/decisions` -- verify decisions array length matches, entries are index format (not full decisions)
4. `/api/decisions/:id` -- verify full decision returned with rationale, alternatives, context fields
5. `/api/decisions/:id` with bad ID -- verify 404 response with error message
6. `/api/graph` -- verify entities and relations arrays, counts match
7. Uninitialized state -- create temp dir WITHOUT `.twining/`, verify all endpoints return `{ initialized: false }` with empty arrays/zeros
8. Unknown API route -- verify request falls through to static file serving (not a 404 from API layer)

**Fetch pattern:** Use Node.js built-in `fetch` (available in Node 18+) or `http.get()` to make requests. Parse JSON responses.

Ensure test cleanup: remove temp directories in afterAll/afterEach.
  </action>
  <verify>
Run `npm test -- test/dashboard/api-routes.test.ts` -- all tests pass.
Run `npm test` -- full test suite passes including new and existing tests.
  </verify>
  <done>
All API endpoint tests pass. Uninitialized state handling verified. 404 for unknown decision ID verified. Full test suite green.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- clean TypeScript compilation
2. `npm test` -- all tests pass (existing + new API tests)
3. Manual: `curl http://localhost:24282/api/status` returns valid JSON with expected fields
4. Manual: `curl http://localhost:24282/api/blackboard` returns entries array
5. Manual: `curl http://localhost:24282/api/decisions` returns decisions array
6. Manual: `curl http://localhost:24282/api/graph` returns entities and relations
</verification>

<success_criteria>
All 5 API endpoints return valid JSON. Uninitialized state returns gracefully. Tests cover all endpoints including error cases. Existing test suite unaffected.
</success_criteria>

<output>
After completion, create `.planning/phases/08-observability-dashboard/08-01-SUMMARY.md`
</output>
