---
phase: 12-coordination-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/utils/types.ts
  - src/engine/coordination.ts
  - test/coordination-engine.test.ts
autonomous: true
requirements: [DEL-01, DEL-08]

must_haves:
  truths:
    - "scoreAgent returns a correctly weighted score combining capability overlap (70%) and liveness (30%)"
    - "discover() returns agents ranked by total_score descending, with matched_capabilities populated"
    - "Zero required capabilities returns all agents ranked by liveness alone (capability_overlap = 0)"
    - "Gone agents can be excluded via include_gone flag"
    - "min_score threshold filters out low-scoring agents"
  artifacts:
    - path: "src/utils/types.ts"
      provides: "DiscoverInput, AgentScore, DiscoverResult, DelegationUrgency, DelegationMetadata, DelegationInput, DelegationResult, CreateHandoffInput types"
      contains: "DiscoverInput"
    - path: "src/engine/coordination.ts"
      provides: "CoordinationEngine class with scoreAgent and discover method"
      exports: ["CoordinationEngine", "scoreAgent"]
    - path: "test/coordination-engine.test.ts"
      provides: "Tests for scoring algorithm and discover method"
      min_lines: 80
  key_links:
    - from: "src/engine/coordination.ts"
      to: "src/storage/agent-store.ts"
      via: "AgentStore.getAll() in discover()"
      pattern: "agentStore\\.getAll"
    - from: "src/engine/coordination.ts"
      to: "src/utils/liveness.ts"
      via: "computeLiveness() in scoreAgent"
      pattern: "computeLiveness"
    - from: "src/engine/coordination.ts"
      to: "src/utils/tags.ts"
      via: "normalizeTags() in scoreAgent"
      pattern: "normalizeTags"
---

<objective>
Add coordination types and implement CoordinationEngine with agent scoring and discovery.

Purpose: Establish the CoordinationEngine class foundation with the scoring algorithm and discover() method that all subsequent coordination features depend on. The scoring algorithm is a pure function (ideal for TDD) that ranks agents by 70% capability overlap + 30% liveness.

Output: CoordinationEngine class with discover(), scoreAgent pure function, all coordination types in types.ts
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-coordination-engine/12-RESEARCH.md
@src/utils/types.ts
@src/engine/decisions.ts
@src/storage/agent-store.ts
@src/utils/liveness.ts
@src/utils/tags.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Add coordination types and write failing tests for scoreAgent and discover</name>
  <files>src/utils/types.ts, test/coordination-engine.test.ts, src/engine/coordination.ts</files>
  <action>
**Step 1: Add coordination types to `src/utils/types.ts`** (after the existing HandoffIndexEntry interface):

```typescript
// Agent discovery result types
export interface DiscoverInput {
  required_capabilities: string[];
  include_gone?: boolean;       // Include gone agents (default: true)
  min_score?: number;           // Minimum total_score threshold (default: 0)
}

export interface AgentScore {
  agent_id: string;
  capabilities: string[];
  role?: string;
  description?: string;
  liveness: AgentLiveness;
  capability_overlap: number;   // 0-1: matched/required
  liveness_score: number;       // active=1.0, idle=0.5, gone=0.1
  total_score: number;          // weighted combination
  matched_capabilities: string[];
}

export interface DiscoverResult {
  agents: AgentScore[];
  total_registered: number;
}

// Delegation types
export type DelegationUrgency = "high" | "normal" | "low";

export interface DelegationMetadata {
  type: "delegation";
  required_capabilities: string[];
  urgency: DelegationUrgency;
  expires_at: string;
  timeout_ms?: number;
}

export interface DelegationInput {
  summary: string;
  required_capabilities: string[];
  urgency?: DelegationUrgency;  // Default: "normal"
  timeout_ms?: number;          // Override default expiry
  scope?: string;
  tags?: string[];
  agent_id?: string;
}

export interface DelegationResult {
  entry_id: string;
  timestamp: string;
  expires_at: string;
  suggested_agents: AgentScore[];
}

// Handoff creation input
export interface CreateHandoffInput {
  source_agent: string;
  target_agent?: string;
  scope?: string;
  summary: string;
  results: HandoffResult[];
  auto_snapshot?: boolean;      // Auto-assemble context snapshot (default: true)
  context_snapshot?: HandoffRecord["context_snapshot"]; // Manual override
}
```

**Step 2: Create stub `src/engine/coordination.ts`** with CoordinationEngine class shell and exported scoreAgent function that throws "not implemented". Constructor takes: AgentStore, HandoffStore, BlackboardEngine, DecisionStore, BlackboardStore, TwiningConfig. Follow the DecisionEngine constructor pattern (store private readonly fields). Stub methods: discover(), postDelegation(), createHandoff(), acknowledgeHandoff(). Export scoreAgent as a standalone pure function.

**Step 3: Write failing tests in `test/coordination-engine.test.ts`:**

Use the same test setup pattern as `test/agent-store.test.ts` (tmpDir with beforeEach/afterEach cleanup). Create all required stores and engine in beforeEach.

Tests for `scoreAgent` pure function:
1. Full capability match with active agent returns capability_overlap=1.0, liveness_score=1.0, total_score=1.0
2. Partial capability match (2/4 tags) returns capability_overlap=0.5
3. No capability match returns capability_overlap=0.0
4. Idle agent gets liveness_score=0.5
5. Gone agent gets liveness_score=0.1
6. Zero required capabilities returns capability_overlap=0 (no NaN), ranked by liveness only
7. Weighted total: verify 0.7*capability + 0.3*liveness for a specific case

Tests for `discover()`:
1. Empty registry returns empty agents array and total_registered=0
2. Multiple agents sorted by total_score descending
3. include_gone=false filters out gone agents
4. min_score filters out low-scoring agents
5. Tags normalized before matching (uppercase input matches lowercase capabilities)

Run `npx vitest run test/coordination-engine.test.ts` -- all tests MUST fail (RED).
  </action>
  <verify>Run `npx vitest run test/coordination-engine.test.ts` -- all tests fail with "not implemented" or similar errors. Types compile without errors: `npx tsc --noEmit`.</verify>
  <done>12+ failing tests for scoreAgent and discover exist. All coordination types added to types.ts. CoordinationEngine stub exists.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement scoreAgent and discover to pass all tests</name>
  <files>src/engine/coordination.ts</files>
  <action>
Implement in `src/engine/coordination.ts`:

**scoreAgent pure function** (exported, not a class method):
```typescript
export function scoreAgent(
  agent: AgentRecord,
  requiredCapabilities: string[],
  livenessThresholds: LivenessThresholds,
  now: Date = new Date(),
): AgentScore
```

Logic:
1. Normalize required capabilities via `normalizeTags(requiredCapabilities)`
2. Find matched capabilities: `agent.capabilities.filter(cap => normalizedRequired.includes(cap))`
3. Compute capability_overlap: `normalizedRequired.length > 0 ? matched.length / normalizedRequired.length : 0`
4. Compute liveness via `computeLiveness(agent.last_active, now, livenessThresholds)`
5. Map liveness to score: active=1.0, idle=0.5, gone=0.1
6. Compute total_score: `capability_overlap * 0.7 + liveness_score * 0.3`
7. Return AgentScore with all fields populated (agent_id, capabilities, role, description from agent record)

**discover method** on CoordinationEngine:
```typescript
async discover(input: DiscoverInput): Promise<DiscoverResult>
```

Logic:
1. Get all agents via `this.agentStore.getAll()`
2. Get liveness thresholds from `this.config.agents?.liveness ?? DEFAULT_LIVENESS_THRESHOLDS`
3. Score each agent via `scoreAgent(agent, input.required_capabilities, thresholds, now)`
4. Filter: if `input.include_gone === false`, exclude gone agents. If `input.min_score !== undefined`, exclude agents below threshold.
5. Sort by total_score descending
6. Return `{ agents: scores, total_registered: agents.length }`

Note: `include_gone` defaults to `true` (include all agents unless explicitly excluded).

Import DEFAULT_LIVENESS_THRESHOLDS from liveness.ts if it exists, otherwise define a local fallback matching config defaults.
  </action>
  <verify>Run `npx vitest run test/coordination-engine.test.ts` -- all tests pass. Run `npx tsc --noEmit` -- no type errors.</verify>
  <done>All scoreAgent and discover tests pass. CoordinationEngine.discover() returns ranked agent scores.</done>
</task>

</tasks>

<verification>
```bash
npx vitest run test/coordination-engine.test.ts
npx tsc --noEmit
```
All coordination-engine tests pass. No type errors. scoreAgent is a pure function testable in isolation.
</verification>

<success_criteria>
- scoreAgent correctly computes 70/30 weighted score from capability overlap and liveness
- discover() returns ranked agents with full AgentScore details
- Edge cases handled: zero required capabilities, empty registry, gone agent filtering, min_score threshold
- All coordination types exported from types.ts
- CoordinationEngine follows established engine class pattern (injectable dependencies)
</success_criteria>

<output>
After completion, create `.planning/phases/12-coordination-engine/12-01-SUMMARY.md`
</output>
