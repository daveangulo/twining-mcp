---
phase: 11-types-and-storage
plan: 03
type: tdd
wave: 2
depends_on:
  - "11-01"
files_modified:
  - src/storage/handoff-store.ts
  - test/handoff-store.test.ts
autonomous: true
requirements:
  - HND-05

must_haves:
  truths:
    - "HandoffStore.create persists a handoff record as an individual JSON file in .twining/handoffs/{ulid}.json"
    - "HandoffStore.create appends a lightweight index entry to .twining/handoffs/index.jsonl"
    - "HandoffStore.get retrieves a single handoff by ID from its individual file"
    - "HandoffStore.list reads the JSONL index and supports filtering by source_agent, target_agent, scope, and since"
    - "HandoffStore.acknowledge updates the acknowledged_by and acknowledged_at fields on the handoff file and rewrites the index entry"
    - "Handoff records persist across sessions (data survives store re-instantiation)"
  artifacts:
    - path: "src/storage/handoff-store.ts"
      provides: "HandoffStore class with create, get, list, acknowledge"
      exports: ["HandoffStore"]
    - path: "test/handoff-store.test.ts"
      provides: "Comprehensive tests for HandoffStore persistence and querying"
  key_links:
    - from: "src/storage/handoff-store.ts"
      to: "src/utils/types.ts"
      via: "imports HandoffRecord, HandoffResult, HandoffIndexEntry types"
      pattern: "import.*HandoffRecord.*types"
    - from: "src/storage/handoff-store.ts"
      to: "src/storage/file-store.ts"
      via: "uses writeJSON, readJSON, appendJSONL, readJSONL, writeJSONL for locked file I/O"
      pattern: "import.*writeJSON.*file-store"
    - from: "src/storage/handoff-store.ts"
      to: "src/utils/ids.ts"
      via: "uses generateId for ULID generation"
      pattern: "import.*generateId.*ids"
---

<objective>
Implement HandoffStore with full CRUD operations using TDD (RED-GREEN-REFACTOR). HandoffStore persists handoff records as individual JSON files in `.twining/handoffs/` with a JSONL index for fast listing and filtering.

Purpose: Handoff records enable agents to pass structured work results and context references between context windows. The store must support creation, retrieval, filtered listing, and acknowledgment -- all persisting to disk for cross-session durability (HND-05).

Output: Working HandoffStore class with comprehensive test coverage.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-types-and-storage/11-RESEARCH.md
@.planning/phases/11-types-and-storage/11-01-SUMMARY.md
@src/utils/types.ts
@src/storage/file-store.ts
@src/storage/decision-store.ts
@src/utils/ids.ts
</context>

<feature>
  <name>HandoffStore</name>
  <files>src/storage/handoff-store.ts, test/handoff-store.test.ts</files>
  <behavior>
HandoffStore manages handoff records using individual JSON files + JSONL index.
Follows DecisionStore's individual-file pattern.

**Constructor:**
- `constructor(twiningDir: string)` -- sets `handoffsDir` to `path.join(twiningDir, "handoffs")` and `indexPath` to `path.join(handoffsDir, "index.jsonl")`

**create(input: Omit&lt;HandoffRecord, "id" | "created_at"&gt;): Promise&lt;HandoffRecord&gt;**
- Generate ULID id via `generateId()`
- Set created_at to now (ISO 8601)
- Write full record to `{handoffsDir}/{id}.json` via writeJSON
- Compute aggregate result_status from results array:
  - If all results have same status, use that status
  - If mixed statuses, use "mixed"
  - If no results, use "completed"
- Create HandoffIndexEntry with id, created_at, source_agent, target_agent, scope, summary, result_status, acknowledged: false
- Append index entry to index.jsonl via appendJSONL
- Return the created HandoffRecord

**get(id: string): Promise&lt;HandoffRecord | null&gt;**
- Read `{handoffsDir}/{id}.json` via readJSON
- Return null if file doesn't exist (catch ENOENT, don't throw)
- Return the parsed HandoffRecord

**list(filters?: { source_agent?: string; target_agent?: string; scope?: string; since?: string; limit?: number }): Promise&lt;HandoffIndexEntry[]&gt;**
- Read all entries from index.jsonl via readJSONL
- Apply filters:
  - source_agent: exact match
  - target_agent: exact match
  - scope: prefix match (entry.scope?.startsWith(filter.scope) || filter.scope.startsWith(entry.scope ?? ""))
  - since: entry.created_at >= filter.since (ISO string comparison)
- Sort by created_at descending (newest first)
- Apply limit (default: no limit)
- Return filtered HandoffIndexEntry array

**acknowledge(id: string, acknowledgedBy: string): Promise&lt;HandoffRecord&gt;**
- Read the handoff file via readJSON; throw if not found
- Set acknowledged_by = acknowledgedBy, acknowledged_at = now
- Rewrite handoff file via writeJSON
- Read full index via readJSONL, find entry by id, set acknowledged = true
- Rewrite full index via writeJSONL
- Return the updated HandoffRecord

**toIndexEntry(record: HandoffRecord): HandoffIndexEntry** (private helper)
- Compute result_status from record.results array
- Return lightweight index entry

Test cases:
- create generates ULID id and sets created_at
- create writes individual JSON file at handoffs/{id}.json
- create appends entry to index.jsonl
- create computes correct result_status ("completed" when all completed)
- create computes "mixed" result_status when results have different statuses
- create computes "completed" result_status when results array is empty
- get returns null for non-existent id
- get returns full record for existing handoff
- get survives store re-instantiation (persistence test -- create, new store instance, get)
- list returns all entries when no filters
- list filters by source_agent
- list filters by target_agent
- list filters by scope (prefix match, bidirectional)
- list filters by since timestamp
- list applies limit
- list combines multiple filters
- list returns newest first (descending created_at)
- acknowledge sets acknowledged_by and acknowledged_at on file
- acknowledge updates index entry acknowledged=true
- acknowledge throws for non-existent handoff
- index gracefully handles missing index.jsonl (returns empty array)
  </behavior>
  <implementation>
Follow DecisionStore pattern:
- Individual JSON files for full records (readJSON/writeJSON)
- JSONL index for fast listing (readJSONL/appendJSONL/writeJSONL)
- File-first writes: always write the JSON file before appending to index
- Graceful handling: if individual file missing but index references it, skip (log warning)

Use `generateId()` from `src/utils/ids.ts` for ULID generation.
Use `ensureDir` from `src/storage/file-store.ts` to create handoffs/ if needed.

For scope filtering, use the same bidirectional prefix matching as existing codebase:
`entry.scope?.startsWith(filterScope) || filterScope.startsWith(entry.scope ?? "")`

Test setup follows existing pattern (decision-store.test.ts):
- beforeEach: create tmpDir, create handoffs/ subdir
- afterEach: rm -rf tmpDir
  </implementation>
</feature>

<verification>
1. `npx vitest run test/handoff-store.test.ts` -- all tests pass
2. `npx vitest run` -- full test suite passes (no regressions)
3. `npx tsc --noEmit` -- compiles cleanly
</verification>

<success_criteria>
- HandoffStore.create persists to individual JSON files + JSONL index
- HandoffStore.get retrieves by ID from individual file
- HandoffStore.list filters by source_agent, target_agent, scope (prefix), since, limit
- HandoffStore.acknowledge updates both individual file and index
- Data survives store re-instantiation (HND-05 cross-session persistence)
- Aggregate result_status correctly computed from individual result statuses
- Comprehensive test suite with 20+ test cases
</success_criteria>

<output>
After completion, create `.planning/phases/11-types-and-storage/11-03-SUMMARY.md`
</output>
