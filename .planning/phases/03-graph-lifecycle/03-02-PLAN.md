---
phase: 03-graph-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/storage/file-store.ts
  - src/engine/decisions.ts
  - src/engine/archiver.ts
  - src/tools/decision-tools.ts
  - src/tools/lifecycle-tools.ts
  - src/server.ts
  - test/decision-engine.test.ts
  - test/archiver.test.ts
autonomous: true
requirements:
  - DCSN-03
  - DCSN-04
  - DCSN-05
  - DCSN-07
  - LIFE-01
  - LIFE-02
  - LIFE-03
  - LIFE-04

must_haves:
  truths:
    - "Agent can trace a decision's dependency chain upstream and downstream, with cycle protection"
    - "Agent can flag a decision for reconsideration, which sets status to provisional and posts a warning"
    - "Human can override a decision with a reason, and optionally provide a replacement decision that auto-creates via decide()"
    - "When a new decision conflicts with an existing active decision in the same domain+scope, the new one is saved as provisional and a warning is posted"
    - "Agent can archive old blackboard entries before a timestamp, decisions are kept, and a summary finding is posted"
    - "twining_status reports real graph counts, actionable warnings (stale provisionals, archive threshold), and a human-readable summary"
  artifacts:
    - path: "src/storage/file-store.ts"
      provides: "writeJSONL function for atomic JSONL rewrite"
      contains: "writeJSONL"
    - path: "src/engine/decisions.ts"
      provides: "trace(), reconsider(), override() methods and conflict detection in decide()"
    - path: "src/engine/archiver.ts"
      provides: "Archiver class with archive() method, template-based summarization"
    - path: "src/tools/decision-tools.ts"
      provides: "twining_trace, twining_reconsider, twining_override tool registrations"
    - path: "src/tools/lifecycle-tools.ts"
      provides: "twining_archive tool and enhanced twining_status with graph counts and warnings"
    - path: "test/decision-engine.test.ts"
      provides: "Tests for trace, reconsider, override, conflict detection"
    - path: "test/archiver.test.ts"
      provides: "Tests for archive flow, decision protection, summary generation"
  key_links:
    - from: "src/engine/decisions.ts"
      to: "src/storage/decision-store.ts"
      via: "get(), getIndex(), updateStatus() for trace/reconsider/override"
      pattern: "this\\.decisionStore"
    - from: "src/engine/decisions.ts"
      to: "src/engine/blackboard.ts"
      via: "post() for conflict warnings and reconsider warnings"
      pattern: "this\\.blackboardEngine\\.post"
    - from: "src/engine/archiver.ts"
      to: "src/storage/file-store.ts"
      via: "readJSONL, writeJSONL, appendJSONL for archive operations"
      pattern: "readJSONL|writeJSONL|appendJSONL"
    - from: "src/tools/lifecycle-tools.ts"
      to: "src/engine/archiver.ts"
      via: "archiver.archive() for twining_archive tool"
      pattern: "archiver\\.archive"
    - from: "src/server.ts"
      to: "src/engine/archiver.ts"
      via: "Archiver creation and wiring into lifecycle tools"
      pattern: "new Archiver"
---

<objective>
Implement full decision lifecycle (trace, reconsider, override, conflict detection), blackboard archiving with summary generation, and enhanced status reporting. This completes all Phase 3 features, giving agents the ability to manage decision evolution, prune old state, and monitor system health.

Purpose: Agents can manage the full lifecycle of decisions (not just create them) and keep the blackboard manageable by archiving old entries. Status provides actionable health information.
Output: Extended DecisionEngine, Archiver, extended tools (3 new decision tools + archive tool + enhanced status), tests.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graph-lifecycle/03-01-SUMMARY.md
@TWINING-DESIGN-SPEC.md
@src/storage/file-store.ts
@src/storage/decision-store.ts
@src/storage/blackboard-store.ts
@src/engine/decisions.ts
@src/engine/blackboard.ts
@src/tools/decision-tools.ts
@src/tools/lifecycle-tools.ts
@src/server.ts
@src/utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decision lifecycle engine extensions with conflict detection and tests</name>
  <files>
    src/engine/decisions.ts
    src/storage/file-store.ts
    test/decision-engine.test.ts
  </files>
  <action>
**file-store.ts extension:**
Add `writeJSONL(filePath: string, data: unknown[]): Promise<void>` to `src/storage/file-store.ts`. This overwrites (not appends) a JSONL file atomically under lock. Ensure parent directory exists, ensure file exists for locking, acquire lock, write `data.map(item => JSON.stringify(item)).join("\n") + "\n"` (or empty string if no data), release lock. This is needed for archive's blackboard rewrite.

**DecisionEngine extensions (src/engine/decisions.ts):**
Add three new methods and modify `decide()`:

1. **`trace(decisionId: string, direction?: "upstream" | "downstream" | "both")`** — Returns `{ chain: TraceEntry[] }`.
   - Build reverse dependency map: for each decision in the index, load its full record and map `depends_on` entries to their dependents.
   - BFS upstream: follow `depends_on` array from the target decision, collecting each decision with its `id, summary, depends_on, dependents, status`.
   - BFS downstream: follow the reverse map from the target decision.
   - Use a `visited` Set to prevent infinite loops from circular dependencies.
   - If `direction` is "both" (default), combine both passes.
   - Throw TwiningError NOT_FOUND if the root decision doesn't exist.

2. **`reconsider(decisionId: string, newContext: string, agentId?: string)`** — Returns `{ flagged: boolean, decision_summary: string }`.
   - Load the decision. Throw NOT_FOUND if missing.
   - If status is "active", update to "provisional" via `decisionStore.updateStatus()`.
   - If status is already not "active" (provisional, superseded, overridden), set `flagged: false`.
   - Post a "warning" entry to blackboard: summary = `"Reconsideration flagged: {decision.summary}"`, detail = newContext, tags = [decision.domain], scope = decision.scope.
   - Check for downstream dependents (decisions whose depends_on includes this ID). If any exist, include their count in the warning detail: "Note: {N} downstream decisions may be affected: {ids}".
   - Do NOT cascade — only the target decision changes status.

3. **`override(decisionId: string, reason: string, newDecision?: string, overriddenBy?: string)`** — Returns `{ overridden: boolean, old_summary: string, new_decision_id?: string }`.
   - Load the decision. Throw NOT_FOUND if missing.
   - Set status to "overridden" via updateStatus. Set `overridden_by` and `override_reason` on the decision (needs a new `updateOverrideFields()` method on DecisionStore, or extend `updateStatus` to accept optional fields).
   - Post a blackboard entry (type "decision"): summary = `"Override: {old_summary} — overridden by {overriddenBy}"`, detail = reason.
   - If `newDecision` is provided, call `this.decide()` with: domain and scope from the old decision, summary = newDecision, context = reason, rationale = reason, supersedes = decisionId, agent_id = overriddenBy ?? "human". Return the new decision's ID.

4. **Conflict detection in `decide()`:**
   - BEFORE creating the new decision (after validation but before `decisionStore.create()`), scan the decision index for conflicts:
     - Same `domain` AND scope prefix overlap (either scope starts with the other) AND `status === "active"` AND `summary !== input.summary` (avoid self-conflict on re-creation).
   - If conflicts found (per user's locked decision): create the decision anyway but with `status: "provisional"`. Post a "warning" entry: summary = `"Potential conflict: new decision may conflict with {N} existing decision(s)"`, detail lists the conflicting decision IDs and summaries.
   - Return conflict info in the response: add `conflicts?: { id: string, summary: string }[]` to the return type.
   - If no conflicts, status remains "active" as before.

**DecisionStore extension (if needed):**
The existing `updateStatus()` only changes status. For override, we also need to set `overridden_by` and `override_reason`. Either:
- Add `updateFields(id: string, fields: Partial<Decision>)` method, or
- Extend `updateStatus` to accept optional override fields.
Choose whichever is simpler. The pattern: read the JSON file, update fields, write back.

**Tests (test/decision-engine.test.ts):**
If this test file exists, extend it. If not, create it. Tests:
- trace(): upstream follows depends_on chain, downstream finds dependents, "both" combines, cycle doesn't loop forever, NOT_FOUND for missing ID.
- reconsider(): active -> provisional, posts warning to blackboard, already-provisional returns flagged:false, includes downstream dependent count in warning.
- override(): sets status to overridden, records overridden_by and reason, posts blackboard entry, auto-creates replacement when newDecision provided.
- conflict detection: new decision in same domain+scope as active -> provisional + warning posted. Different domain same scope -> no conflict. Same domain different scope -> no conflict. Same domain prefix-overlapping scope -> conflict detected.
  </action>
  <verify>Run `npx vitest run test/decision-engine.test.ts` — all tests pass. Run `npx tsc --noEmit` — no type errors.</verify>
  <done>DecisionEngine has trace, reconsider, override methods. Conflict detection in decide() marks conflicting decisions as provisional and posts warnings. writeJSONL available in file-store. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Archiver engine, tools, enhanced status, and server wiring</name>
  <files>
    src/engine/archiver.ts
    src/tools/decision-tools.ts
    src/tools/lifecycle-tools.ts
    src/server.ts
    test/archiver.test.ts
  </files>
  <action>
**Archiver (src/engine/archiver.ts):**
New file. Constructor takes `twiningDir`, `BlackboardStore`, `BlackboardEngine`, `IndexManager | null`.

`archive(options: { before?: string, keep_decisions?: boolean, summarize?: boolean })` — Returns `{ archived_count, archive_file, summary? }`.
1. Read all entries from blackboard.jsonl via `readJSONL`.
2. Partition: entries with `timestamp < cutoff` (cutoff = options.before ?? now) go to archive, EXCEPT entries where `entry_type === "decision"` when `keep_decisions` is true (default true). This implements LIFE-01 and LIFE-03.
3. If nothing to archive, return `{ archived_count: 0, archive_file: "", summary: undefined }`.
4. Write archived entries to `archive/{YYYY-MM-DD}-blackboard.jsonl` using `appendJSONL` (appends to same-day file if it exists).
5. Rewrite `blackboard.jsonl` with only kept entries using `writeJSONL` (the new function). Hold proper-lockfile lock on blackboard.jsonl for the FULL read-partition-rewrite cycle to prevent data loss from concurrent posts.
6. Remove archived entry embeddings from index via `indexManager.removeEntries("blackboard", archivedIds)` — wrap in try/catch, best-effort only. Note: `removeEntries` may not exist on IndexManager yet; if not, add a simple method that loads the index, filters out the IDs, and saves.
7. If `summarize` is true (default), build a summary using `buildSummary(archived)`:
   - Group by entry_type, count each type.
   - For each type, include top 3 summaries (by recency).
   - Template: "Archive summary: {total} entries archived. {type}: {count} entries ({top summaries}). ..."
   - Cap total summary at 2000 chars.
   - Post as a "finding" entry via `blackboardEngine.post({ entry_type: "finding", summary: "Archive: {count} entries archived", detail: summary, tags: ["archive"], scope: "project" })`. This implements LIFE-02.
8. Return results.

**Decision tools extension (src/tools/decision-tools.ts):**
Add 3 new tools in the existing `registerDecisionTools` function:

1. `twining_trace` — Input: `{ decision_id: z.string(), direction: z.enum(["upstream","downstream","both"]).optional() }`. Call `engine.trace(args.decision_id, args.direction)`. Return result.

2. `twining_reconsider` — Input: `{ decision_id: z.string(), new_context: z.string(), agent_id: z.string().optional() }`. Call `engine.reconsider(args.decision_id, args.new_context, args.agent_id)`. Return result.

3. `twining_override` — Input: `{ decision_id: z.string(), reason: z.string(), new_decision: z.string().optional(), overridden_by: z.string().optional() }`. Call `engine.override(args.decision_id, args.reason, args.new_decision, args.overridden_by)`. Return result.

All use the same TwiningError/toolError pattern as existing tools.

**Lifecycle tools extension (src/tools/lifecycle-tools.ts):**
1. Add `twining_archive` tool — Input: `{ before: z.string().optional(), keep_decisions: z.boolean().optional(), summarize: z.boolean().optional() }`. Call `archiver.archive(args)`. Return result.

2. Enhance `twining_status`:
   - Accept `GraphStore` in the `registerLifecycleTools` signature (update the function signature to include graphStore and archiver).
   - Replace placeholder `graph_entities: 0` with real counts from `graphStore.getEntities().length` and `graphStore.getRelations().length`.
   - Add actionable warnings array:
     - Stale provisionals: decisions with status "provisional" older than 7 days. Message: "{count} provisional decisions older than 7 days need resolution".
     - Archive needed: when `blackboard_entries >= config.max_blackboard_entries_before_archive`. Message: "Blackboard has {count} entries, archive recommended (threshold: {threshold})".
     - Orphan entities: entities with zero relations. Message: "{count} graph entities have no relations".
   - Add `summary` string: "Healthy|Needs attention. {blackboard_entries} blackboard entries, {active_decisions} active decisions, {graph_entities} graph entities. {warnings summary}."
   - Return the enhanced status object with `warnings: string[]` and `summary: string` fields added to existing return.

**Server wiring (src/server.ts):**
- Import `Archiver` from `./engine/archiver.js`
- In `createServer()`:
  - Create `archiver = new Archiver(twiningDir, blackboardStore, blackboardEngine, indexManager)`
  - Update `registerLifecycleTools` call to pass `graphStore` and `archiver`: `registerLifecycleTools(server, twiningDir, blackboardStore, decisionStore, graphStore, archiver, config)`
  - Note: `graphStore` and `graphEngine` are already created in Plan 03-01.

**Archiver tests (test/archiver.test.ts):**
- Archive moves entries older than cutoff to archive file, keeping newer entries in blackboard.
- Decision entries are NEVER archived (even if older than cutoff).
- Summary finding is posted to blackboard when summarize=true.
- Empty archive (nothing matches) returns archived_count: 0.
- Multiple archives on same day append to same archive file.
- Summary is capped at reasonable length.

**IndexManager extension (if needed):**
If `removeEntries(namespace, ids)` doesn't exist on IndexManager, add it: load the index file, filter out entries whose ID is in the removal set, save back. This is the minimal change needed for archive cleanup.
  </action>
  <verify>Run `npx vitest run` — ALL tests pass (existing + new). Run `npx tsc --noEmit` — no type errors. Run `npm run build` — clean build.</verify>
  <done>Full decision lifecycle works (trace, reconsider, override, conflict detection). Archiver moves old entries preserving decisions. Status reports real graph counts, actionable warnings, and human-readable summary. All tests pass, build clean. Phase 3 complete.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (full suite including new Phase 3 tests)
2. `npx tsc --noEmit` — no type errors across the entire codebase
3. `npm run build` — clean build to dist/
4. trace() follows depends_on upstream and reverse-map downstream with cycle protection
5. reconsider() flips active->provisional and posts warning with downstream impact note
6. override() sets overridden status with reason, optionally auto-creates replacement via decide()
7. Conflict detection: same domain + prefix-overlapping scope -> provisional + warning posted (per user's locked decision)
8. Archive partitions by timestamp, never archives decisions, posts summary finding, rewrites blackboard atomically
9. twining_status shows real graph counts, actionable warnings for stale provisionals and archive threshold, and a summary string
</verification>

<success_criteria>
- Decision lifecycle complete: trace, reconsider, override all functional with tests
- Conflict detection in decide() creates provisional decisions with warnings (per locked user decision)
- Archiver moves old entries while protecting decisions, generates summary findings
- Enhanced twining_status shows graph counts, warnings, and summary
- 7 new/updated MCP tools work: twining_trace, twining_reconsider, twining_override, twining_archive, enhanced twining_status (plus 4 graph tools from Plan 01)
- All tests pass, build clean, no type errors
- Phase 3 fully complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-graph-lifecycle/03-02-SUMMARY.md`
</output>
