---
phase: 03-graph-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/graph-store.ts
  - src/engine/graph.ts
  - src/tools/graph-tools.ts
  - src/engine/context-assembler.ts
  - src/server.ts
  - test/graph-store.test.ts
  - test/graph-engine.test.ts
autonomous: true
requirements:
  - GRPH-01
  - GRPH-02
  - GRPH-03
  - GRPH-04

must_haves:
  truths:
    - "Agent can add an entity and get back its ID, then add the same name+type again and get an update (upsert)"
    - "Agent can add a relation between two entities by ID or name, and get an error for ambiguous name matches"
    - "Agent can traverse neighbors from an entity at depth 1-3 with optional relation type filter"
    - "Agent can search entities by substring on name or property values, filtered by entity type"
    - "Context assembly populates related_entities from the graph for the given scope"
  artifacts:
    - path: "src/storage/graph-store.ts"
      provides: "GraphStore with addEntity (upsert), addRelation, getEntities, getRelations, getEntityById, getEntityByName"
    - path: "src/engine/graph.ts"
      provides: "GraphEngine with neighbors (BFS depth-limited) and query (substring matching)"
    - path: "src/tools/graph-tools.ts"
      provides: "MCP tool handlers for twining_add_entity, twining_add_relation, twining_neighbors, twining_graph_query"
    - path: "test/graph-store.test.ts"
      provides: "Tests for GraphStore CRUD and upsert semantics"
    - path: "test/graph-engine.test.ts"
      provides: "Tests for BFS neighbor traversal, depth limiting, query matching"
  key_links:
    - from: "src/storage/graph-store.ts"
      to: "src/storage/file-store.ts"
      via: "readJSON, writeJSON for entities.json and relations.json"
      pattern: "readJSON|writeJSON"
    - from: "src/engine/graph.ts"
      to: "src/storage/graph-store.ts"
      via: "GraphStore for entity/relation reads"
      pattern: "this\\.graphStore"
    - from: "src/tools/graph-tools.ts"
      to: "src/engine/graph.ts"
      via: "GraphEngine for neighbors and query"
      pattern: "engine\\.neighbors|engine\\.query"
    - from: "src/engine/context-assembler.ts"
      to: "src/engine/graph.ts"
      via: "GraphEngine.neighbors for related_entities population"
      pattern: "graphEngine\\.neighbors"
    - from: "src/server.ts"
      to: "src/tools/graph-tools.ts"
      via: "registerGraphTools wiring"
      pattern: "registerGraphTools"
---

<objective>
Implement the knowledge graph storage, engine, tools, and context assembly integration. Agents will be able to add entities (with upsert semantics), add relationships between entities, traverse neighbors with BFS at configurable depth, and search entities by name/property substring matching. Context assembly will populate the `related_entities` field from graph data.

Purpose: Enables agents to build and query a knowledge graph of code entities, which is the structural backbone for understanding code relationships across sessions.
Output: GraphStore, GraphEngine, graph MCP tools (4 tools), context-assembler integration, tests.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@TWINING-DESIGN-SPEC.md
@src/storage/file-store.ts
@src/storage/decision-store.ts
@src/utils/types.ts
@src/server.ts
@src/engine/context-assembler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Graph storage and engine with tests</name>
  <files>
    src/storage/graph-store.ts
    src/engine/graph.ts
    test/graph-store.test.ts
    test/graph-engine.test.ts
  </files>
  <action>
**GraphStore (src/storage/graph-store.ts):**
Create a class following the DecisionStore pattern. Uses `readJSON`/`writeJSON` from `file-store.ts` for `graph/entities.json` and `graph/relations.json`.

Methods:
- `constructor(twiningDir: string)` — sets paths to `graph/entities.json` and `graph/relations.json`
- `addEntity(input: { name, type, properties? })` — Upsert: read entities.json under lock, find by name+type. If found, merge properties and update `updated_at`. If not, create new with `generateId()`, push, write. Return the Entity.
- `addRelation(input: { source, target, type, properties? })` — Source/target can be entity ID or name. Resolve each: try ID match first, then name match. If name matches multiple entities, throw TwiningError with code "AMBIGUOUS_ENTITY" listing the matches. Validate both source and target resolve. Create Relation with `generateId()`, append, write. Return the Relation.
- `getEntities()` — readJSON, return Entity[]. Return [] if file doesn't exist.
- `getRelations()` — readJSON, return Relation[]. Return [] if file doesn't exist.
- `getEntityById(id: string)` — find in entities array.
- `getEntityByName(name: string, type?: string)` — find by name, optionally filter by type.

Use `proper-lockfile` for the entire read-modify-write cycle in addEntity and addRelation (same pattern as DecisionStore). Use Entity and Relation types from `utils/types.ts`. Use `generateId()` from `utils/ids.ts`.

**GraphEngine (src/engine/graph.ts):**
Business logic layer. Constructor takes `GraphStore`.

Methods:
- `addEntity(input)` — delegates to graphStore.addEntity()
- `addRelation(input)` — delegates to graphStore.addRelation()
- `neighbors(entityIdOrName: string, depth?: number, relationTypes?: string[])` — BFS traversal:
  1. Resolve center entity (by ID then name). Throw TwiningError NOT_FOUND if missing.
  2. Build adjacency list from relations (both directions: outgoing and incoming).
  3. Filter by relationTypes if provided.
  4. BFS from center, depth clamped to max 3. Collect unique neighbors with their relation type and direction.
  5. Return `{ center: Entity, neighbors: { entity, relation, direction }[] }`.
  Use a visited Set to prevent cycles.
- `query(queryStr: string, entityTypes?: string[], limit?: number)` — Substring search:
  1. Load all entities.
  2. Case-insensitive substring match on entity name OR any property value.
  3. Filter by entityTypes if provided.
  4. Return up to limit (default 10) matches as `{ entities: Entity[] }`.

**Tests:**
- `graph-store.test.ts`: Test addEntity creates new, upsert updates existing, addRelation resolves by ID and name, addRelation errors on ambiguous name, addRelation errors on missing entity, getEntities/getRelations return empty for missing files.
- `graph-engine.test.ts`: Test neighbors at depth 1 (direct), depth 2 (two hops), depth 3 (max), with relation type filter, with cycle (no infinite loop). Test query substring match on name, on property value, with type filter, with limit. Test entity not found error.
  </action>
  <verify>Run `npx vitest run test/graph-store.test.ts test/graph-engine.test.ts` — all tests pass.</verify>
  <done>GraphStore supports entity upsert and relation creation with entity resolution. GraphEngine supports BFS neighbor traversal (depth 1-3) and substring query. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Graph MCP tools, context assembly integration, and server wiring</name>
  <files>
    src/tools/graph-tools.ts
    src/engine/context-assembler.ts
    src/server.ts
  </files>
  <action>
**Graph tools (src/tools/graph-tools.ts):**
Create new file following the pattern in `decision-tools.ts`. Export `registerGraphTools(server: McpServer, engine: GraphEngine)`.

Register 4 tools:

1. `twining_add_entity` — Input: `{ name: z.string(), type: z.string(), properties: z.record(z.string()).optional() }`. Call `engine.addEntity(args)`. Return `{ id }`. Catch TwiningError for structured errors.

2. `twining_add_relation` — Input: `{ source: z.string(), target: z.string(), type: z.string(), properties: z.record(z.string()).optional() }`. Call `engine.addRelation(args)`. Return `{ id }`. Catch TwiningError (especially AMBIGUOUS_ENTITY and NOT_FOUND).

3. `twining_neighbors` — Input: `{ entity: z.string(), depth: z.number().optional(), relation_types: z.array(z.string()).optional() }`. Call `engine.neighbors(args.entity, args.depth, args.relation_types)`. Return full result. Catch TwiningError.

4. `twining_graph_query` — Input: `{ query: z.string(), entity_types: z.array(z.string()).optional(), limit: z.number().optional() }`. Call `engine.query(args.query, args.entity_types, args.limit)`. Return result.

All handlers use `toolResult` for success and `toolError` for failures, matching existing patterns.

**Context assembler update (src/engine/context-assembler.ts):**
- Add optional `GraphEngine` parameter to constructor (after config). Store as `private readonly graphEngine: GraphEngine | null`.
- In the `assemble()` method, after building the main context but before returning, populate `related_entities`:
  1. If graphEngine is available, try to find entities whose name matches the scope (or file paths in the scope).
  2. For each found entity, call `graphEngine.neighbors(entity.id, 1)` to get immediate neighbors.
  3. Map to `{ name, type, relations: ["relation_type: target_name", ...] }`.
  4. Wrap in try/catch — graph errors should never break context assembly. On failure, leave `related_entities` as empty array.

**Server wiring (src/server.ts):**
- Import GraphStore from `./storage/graph-store.js`
- Import GraphEngine from `./engine/graph.js`
- Import registerGraphTools from `./tools/graph-tools.js`
- In `createServer()`:
  - Create `graphStore = new GraphStore(twiningDir)`
  - Create `graphEngine = new GraphEngine(graphStore)`
  - Pass `graphEngine` to `ContextAssembler` constructor
  - Call `registerGraphTools(server, graphEngine)`
  </action>
  <verify>Run `npx vitest run` — all tests pass (existing 159 + new graph tests). Run `npx tsc --noEmit` — no type errors. Run `npm run build` — builds cleanly.</verify>
  <done>Four graph MCP tools registered and working. Context assembly populates related_entities from graph. Server wires everything together. Full build passes with all tests green.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (159 existing + new graph tests)
2. `npx tsc --noEmit` — no type errors
3. `npm run build` — clean build to dist/
4. Graph store correctly handles entity upsert (same name+type updates, different name+type creates)
5. BFS traversal respects depth limit and handles cycles
6. Entity resolution in addRelation tries ID first, then name, errors on ambiguity
7. Context assembly's related_entities field is populated when graph has data
</verification>

<success_criteria>
- GraphStore, GraphEngine, graph-tools all implemented with tests
- Four MCP tools registered: twining_add_entity, twining_add_relation, twining_neighbors, twining_graph_query
- Context assembler populates related_entities from graph data
- All tests pass, build clean, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-graph-lifecycle/03-01-SUMMARY.md`
</output>
