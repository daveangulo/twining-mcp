---
phase: 01-foundation-core-data
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/utils/types.ts
  - src/utils/ids.ts
  - src/utils/tokens.ts
  - src/utils/errors.ts
  - src/config.ts
  - src/storage/file-store.ts
  - src/storage/blackboard-store.ts
  - src/storage/decision-store.ts
  - src/storage/init.ts
  - test/utils.test.ts
  - test/file-store.test.ts
  - test/blackboard-store.test.ts
  - test/decision-store.test.ts
  - package.json
  - tsconfig.json
autonomous: true
requirements:
  - FOUND-01
  - FOUND-02
  - FOUND-03
  - FOUND-04
  - FOUND-05
  - FOUND-06
  - BLKB-05
  - BLKB-06
  - DCSN-06

must_haves:
  truths:
    - "ULID generation produces valid, temporally sortable 26-character IDs"
    - "Token estimation returns text.length / 4 rounded up"
    - "File store can append a JSON line to a JSONL file and read it back"
    - "File store uses advisory locking for all writes (concurrent writers don't corrupt data)"
    - "Blackboard store appends entries and reads them back with filters (type, tags, scope, since, limit)"
    - "Decision store creates individual JSON files and maintains an index for fast lookup"
    - "Directory initialization creates .twining/ with config.yml, empty data files, and .gitignore"
    - "Config loads from .twining/config.yml with sensible defaults when keys are missing"
    - "Corrupt JSONL lines are skipped on read rather than crashing"
  artifacts:
    - path: "src/utils/types.ts"
      provides: "All TypeScript interfaces from design spec (BlackboardEntry, Decision, Entity, Relation, AssembledContext, Config)"
    - path: "src/utils/ids.ts"
      provides: "ULID generation wrapper"
      exports: ["generateId"]
    - path: "src/utils/tokens.ts"
      provides: "Token estimation utility"
      exports: ["estimateTokens"]
    - path: "src/utils/errors.ts"
      provides: "Structured error response helpers for MCP tool handlers"
      exports: ["toolResult", "toolError", "TwiningError"]
    - path: "src/config.ts"
      provides: "Config loading from YAML with defaults"
      exports: ["loadConfig", "DEFAULT_CONFIG"]
    - path: "src/storage/file-store.ts"
      provides: "Low-level file I/O with locking: readJSON, writeJSON, appendJSONL, readJSONL"
      exports: ["readJSON", "writeJSON", "appendJSONL", "readJSONL"]
    - path: "src/storage/blackboard-store.ts"
      provides: "Blackboard CRUD: appendEntry, readEntries with filters"
      exports: ["BlackboardStore"]
    - path: "src/storage/decision-store.ts"
      provides: "Decision CRUD: createDecision, getDecision, getDecisionsByScope, updateDecisionStatus"
      exports: ["DecisionStore"]
    - path: "src/storage/init.ts"
      provides: "Directory initialization: createTwiningDir"
      exports: ["initTwiningDir", "ensureInitialized"]
  key_links:
    - from: "src/storage/blackboard-store.ts"
      to: "src/storage/file-store.ts"
      via: "appendJSONL and readJSONL for blackboard.jsonl"
      pattern: "appendJSONL|readJSONL"
    - from: "src/storage/decision-store.ts"
      to: "src/storage/file-store.ts"
      via: "writeJSON and readJSON for individual decision files and index"
      pattern: "writeJSON|readJSON"
    - from: "src/storage/init.ts"
      to: "src/config.ts"
      via: "DEFAULT_CONFIG for writing initial config.yml"
      pattern: "DEFAULT_CONFIG"
    - from: "src/storage/blackboard-store.ts"
      to: "src/utils/types.ts"
      via: "BlackboardEntry interface for type safety"
      pattern: "BlackboardEntry"
---

<objective>
Build the utils layer (types, IDs, tokens, errors), config loader, and storage layer (file-store with locking, blackboard-store, decision-store, init) with comprehensive tests.

Purpose: Establish the foundational data layer that all engine and tool code depends on. Every subsequent plan imports from these modules. File locking ensures concurrent agent safety. Tests verify correctness before building on top.

Output: Working, tested storage layer in src/utils/, src/config.ts, src/storage/ with vitest tests passing.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@TWINING-DESIGN-SPEC.md
@CLAUDE.md
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project setup, types, and utility modules</name>
  <files>
    package.json
    tsconfig.json
    src/utils/types.ts
    src/utils/ids.ts
    src/utils/tokens.ts
    src/utils/errors.ts
    src/config.ts
    test/utils.test.ts
    vitest.config.ts
  </files>
  <action>
**Project setup:**
- Update `package.json`: change `"type"` to `"module"`, add `"bin": { "twining-mcp": "./dist/index.js" }`, update scripts to include `"build": "tsc"`, `"test": "vitest run"`, `"test:watch": "vitest"`. Add `js-yaml` and `zod` as dependencies. Add `@types/proper-lockfile` and `@types/js-yaml` as devDependencies.
- Update `tsconfig.json`: set `"rootDir": "./src"`, `"outDir": "./dist"`, add `"node"` to `types` array, uncomment `"lib": ["esnext"]`.

**src/utils/types.ts:**
Define all interfaces from TWINING-DESIGN-SPEC.md section 3: `BlackboardEntry` (with all 10 entry types as a union type), `Decision` (with status, confidence, alternatives), `Entity`, `Relation`, `AssembledContext`. Also define `TwiningConfig` interface matching the YAML config structure from spec section 2.3. Export `EntryType` as a const array of the 10 valid types for Zod schema reuse.

**src/utils/ids.ts:**
Export `generateId()` that calls `ulid()` from the `ulid` package. Single function, single export.

**src/utils/tokens.ts:**
Export `estimateTokens(text: string): number` returning `Math.ceil(text.length / 4)`.

**src/utils/errors.ts:**
Export:
- `toolResult(data: object)` — returns `{ content: [{ type: "text", text: JSON.stringify(data) }] }`
- `toolError(message: string, code: string)` — returns `{ content: [{ type: "text", text: JSON.stringify({ error: true, message, code }) }] }`
- `TwiningError` class extending Error with a `code` property

**src/config.ts:**
Export `DEFAULT_CONFIG` matching spec section 2.3 (version, project_name, embedding_model, archive settings, context_assembly weights, conflict_resolution).
Export `loadConfig(twiningDir: string): TwiningConfig` — reads `config.yml` using `js-yaml`, deep-merges with DEFAULT_CONFIG so missing keys get defaults. If file doesn't exist, returns DEFAULT_CONFIG.

**vitest.config.ts:**
Configure vitest with `test.globals: true` disabled (use explicit imports), `test.include: ["test/**/*.test.ts"]`.

**test/utils.test.ts:**
Test `generateId()` returns 26-char string, two calls produce different IDs, IDs are lexicographically sortable when generated in sequence.
Test `estimateTokens` with empty string (0), "test" (1), 100-char string (25).
Test `toolResult` returns correct MCP format. Test `toolError` returns error format with code.
Test `loadConfig` with missing file returns defaults, with partial file merges correctly.
  </action>
  <verify>
Run `npx vitest run test/utils.test.ts` — all tests pass.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
All utility modules export correct functions with proper types. Config loader merges YAML with defaults. All tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: File store with locking and init module</name>
  <files>
    src/storage/file-store.ts
    src/storage/init.ts
    test/file-store.test.ts
  </files>
  <action>
**src/storage/file-store.ts:**
Low-level file I/O with advisory locking. All functions operate on absolute paths.

Export:
- `readJSON<T>(filePath: string): Promise<T>` — reads and parses JSON file. Returns parsed object. Throws if file doesn't exist.
- `writeJSON(filePath: string, data: unknown): Promise<void>` — acquires lock on filePath, writes JSON with 2-space indent, releases lock. Use `proper-lockfile.lock()` with retries: `{ retries: { retries: 5, minTimeout: 50, maxTimeout: 500 }, stale: 10000 }`.
- `appendJSONL(filePath: string, data: unknown): Promise<void>` — acquires lock on filePath, appends `JSON.stringify(data) + "\n"` using `fs.appendFileSync`, releases lock. Same retry config.
- `readJSONL<T>(filePath: string): Promise<T[]>` — reads file, splits by newline, filters empty lines, parses each line with try/catch (skip corrupt lines, log warning to stderr). No locking needed for reads.
- `ensureDir(dirPath: string): void` — `fs.mkdirSync(dirPath, { recursive: true })`.

Lock strategy per user decision: use retry with backoff. Stale lock threshold: 10 seconds. On lock compromise (another process broke the lock), log warning to stderr and retry.

**src/storage/init.ts:**
Export `initTwiningDir(projectRoot: string): void` — creates `.twining/` directory structure per spec section 2.2 if it doesn't exist:
- `.twining/config.yml` (from DEFAULT_CONFIG, project_name = basename of projectRoot)
- `.twining/blackboard.jsonl` (empty file)
- `.twining/decisions/index.json` (empty array `[]`)
- `.twining/graph/entities.json` (empty array `[]`)
- `.twining/graph/relations.json` (empty array `[]`)
- `.twining/embeddings/` (empty dir)
- `.twining/archive/` (empty dir)
- `.twining/.gitignore` with content: `embeddings/*.index\narchive/\n`

Export `ensureInitialized(projectRoot: string): string` — calls `initTwiningDir` if needed, returns the `.twining/` path.

**test/file-store.test.ts:**
Use vitest with `beforeEach`/`afterEach` creating a temp directory via `fs.mkdtempSync`.
Test `writeJSON` + `readJSON` round-trip.
Test `appendJSONL` + `readJSONL` round-trip with multiple entries.
Test `readJSONL` skips corrupt lines (write a file with one valid line and one invalid line, expect only the valid entry returned).
Test `appendJSONL` under simulated concurrent calls (call appendJSONL 10 times concurrently with Promise.all, verify all 10 entries present and no corruption).
Test `initTwiningDir` creates correct directory structure and files. Test idempotency (calling twice doesn't error or overwrite).
  </action>
  <verify>
Run `npx vitest run test/file-store.test.ts` — all tests pass including concurrency test.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
File store provides locked read/write/append operations. Init creates .twining/ structure. Concurrent writes don't corrupt data. Corrupt lines are skipped gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Blackboard store and decision store</name>
  <files>
    src/storage/blackboard-store.ts
    src/storage/decision-store.ts
    test/blackboard-store.test.ts
    test/decision-store.test.ts
  </files>
  <action>
**src/storage/blackboard-store.ts:**
Class `BlackboardStore` constructed with `twiningDir: string` (path to `.twining/`).

Methods:
- `append(entry: Omit<BlackboardEntry, "id" | "timestamp">): Promise<BlackboardEntry>` — generates ULID, adds ISO timestamp, calls `appendJSONL` to write to `blackboard.jsonl`. Returns the full entry.
- `read(filters?: { entry_types?: string[], tags?: string[], scope?: string, since?: string, limit?: number }): Promise<{ entries: BlackboardEntry[], total_count: number }>` — calls `readJSONL` for `blackboard.jsonl`, applies filters:
  - `entry_types`: include only matching types (OR match)
  - `tags`: include entries where any tag matches any filter tag (OR match)
  - `scope`: prefix match — entry.scope starts with filter scope, OR filter scope starts with entry.scope (bidirectional prefix for hierarchy)
  - `since`: include only entries with timestamp >= since
  - Apply limit AFTER filtering. Return total_count as count before limit.
- `recent(n?: number, entry_types?: string[]): Promise<BlackboardEntry[]>` — read all, optionally filter by types, return last N (default 20).

**src/storage/decision-store.ts:**
Class `DecisionStore` constructed with `twiningDir: string`.

Methods:
- `create(input: Omit<Decision, "id" | "timestamp" | "status">): Promise<Decision>` — generates ULID, adds ISO timestamp, sets status to "active". Writes `decisions/{ulid}.json` via `writeJSON`. Updates `decisions/index.json` by reading current index, appending summary entry (id, timestamp, domain, scope, summary, confidence, status, affected_files, affected_symbols), writing back — all under a single lock on index.json.
- `get(id: string): Promise<Decision | null>` — reads `decisions/{id}.json` via `readJSON`, returns null if not found.
- `getByScope(scope: string): Promise<Decision[]>` — reads index.json, filters by scope prefix match OR affected_files/affected_symbols match. For each matching entry, loads full decision file. Returns sorted by timestamp descending.
- `updateStatus(id: string, status: Decision["status"], extra?: Partial<Decision>): Promise<void>` — reads decision file, updates status and any extra fields, writes back. Also updates the status in index.json.
- `getIndex(): Promise<DecisionIndexEntry[]>` — reads and returns the full index.

Define `DecisionIndexEntry` type for the index entries (subset of Decision fields used for fast lookup).

**test/blackboard-store.test.ts:**
Use temp dir setup. Test:
- Append entry and read it back
- Filter by entry_type (post 3 types, filter for 1)
- Filter by tags (post entries with different tags, filter)
- Filter by scope with prefix matching
- Filter by since timestamp
- Limit works (post 10 entries, limit 5, get 5 + total_count 10)
- Recent returns last N entries in order
- Entry types validated against ENTRY_TYPES constant

**test/decision-store.test.ts:**
Use temp dir setup. Test:
- Create decision and get it back by ID
- getByScope returns matching decisions (exact scope match and prefix match)
- getByScope returns empty array for non-matching scope
- updateStatus changes status in both file and index
- Index stays in sync after multiple creates
- Concurrent creates don't corrupt the index (Promise.all 5 creates, verify all 5 in index)
  </action>
  <verify>
Run `npx vitest run test/blackboard-store.test.ts test/decision-store.test.ts` — all tests pass.
Run `npx tsc --noEmit` — no type errors.
Run `npx vitest run` — ALL tests pass (full suite).
  </verify>
  <done>
Blackboard store appends/reads/filters entries correctly. Decision store creates/reads/updates decisions with a maintained index. Both handle concurrent access safely. Full test suite green.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors across all modules
2. `npx vitest run` — all tests pass (utils, file-store, blackboard-store, decision-store)
3. Verify `.twining/` directory structure created correctly by init module (check via test)
4. Verify concurrent write safety by checking blackboard and decision concurrency tests
5. Verify corrupt JSONL handling by checking file-store skip test
</verification>

<success_criteria>
- All TypeScript interfaces match TWINING-DESIGN-SPEC.md data models exactly
- ULID IDs are 26 characters and temporally sortable
- Token estimation uses 4 chars/token heuristic
- File store uses proper-lockfile for all writes with retry backoff
- Blackboard store supports all 10 entry types and all filter combinations
- Decision store maintains index in sync with individual files
- Init creates correct .twining/ structure with YAML config
- Config loader merges YAML with defaults
- All tests pass, including concurrency tests
- No console.log calls anywhere (only console.error for warnings)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-data/01-01-SUMMARY.md`
</output>
