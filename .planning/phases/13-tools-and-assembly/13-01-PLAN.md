---
phase: 13-tools-and-assembly
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/coordination-tools.ts
  - src/tools/lifecycle-tools.ts
  - src/server.ts
  - test/coordination-tools.test.ts
  - test/tools.test.ts
autonomous: true
requirements: [DEL-04, DEL-05]

must_haves:
  truths:
    - "twining_agents returns all registered agents with capabilities, role, description, and liveness status"
    - "twining_agents with include_gone=false filters out gone agents"
    - "twining_agents returns total_registered and active_count metrics"
    - "twining_status includes registered_agents and active_agents counts"
  artifacts:
    - path: "src/tools/coordination-tools.ts"
      provides: "registerCoordinationTools function with twining_agents tool"
      exports: ["registerCoordinationTools"]
    - path: "test/coordination-tools.test.ts"
      provides: "Tests for twining_agents tool"
      min_lines: 80
  key_links:
    - from: "src/tools/coordination-tools.ts"
      to: "AgentStore.getAll()"
      via: "agentStore.getAll() in twining_agents handler"
      pattern: "agentStore\\.getAll"
    - from: "src/tools/coordination-tools.ts"
      to: "computeLiveness"
      via: "import from liveness.ts"
      pattern: "computeLiveness"
    - from: "src/tools/lifecycle-tools.ts"
      to: "AgentStore.getAll()"
      via: "agentStore.getAll() in twining_status handler"
      pattern: "agentStore.*getAll"
    - from: "src/server.ts"
      to: "registerCoordinationTools"
      via: "import and call in createServer"
      pattern: "registerCoordinationTools"
---

<objective>
Create the `twining_agents` MCP tool and extend `twining_status` with agent registry counts.

Purpose: Expose the agent coordination system through the MCP tool surface so agents can query who else is registered, what capabilities exist, and see agent counts in health checks.

Output: New `coordination-tools.ts` with `twining_agents` tool, updated `lifecycle-tools.ts` with agent counts in status, wired in `server.ts`, with full test coverage.
</objective>

<execution_context>
@/Users/dave/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dave/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/tools/lifecycle-tools.ts
@src/tools/blackboard-tools.ts
@src/server.ts
@src/utils/types.ts
@src/utils/liveness.ts
@src/storage/agent-store.ts
@src/engine/coordination.ts
@test/tools.test.ts
@.planning/phases/13-tools-and-assembly/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coordination-tools.ts with twining_agents tool and its tests</name>
  <files>src/tools/coordination-tools.ts, test/coordination-tools.test.ts</files>
  <action>
Create `src/tools/coordination-tools.ts` following the exact pattern from `blackboard-tools.ts`:

1. Export `registerCoordinationTools(server, agentStore, coordinationEngine, config)` function
2. Register `twining_agents` tool with:
   - Description: "List all registered agents with their capabilities and liveness status."
   - Input schema: `include_gone` (boolean, optional, default true) — whether to include gone agents
   - Handler:
     a. Call `agentStore.getAll()` to get all agents
     b. Get liveness thresholds from `config.agents?.liveness ?? DEFAULT_LIVENESS_THRESHOLDS`
     c. Map each agent to `{ agent_id, capabilities, role, description, registered_at, last_active, liveness: computeLiveness(agent.last_active, now, thresholds) }`
     d. If `include_gone === false`, filter out agents where `liveness === "gone"`
     e. Return `toolResult({ agents: filtered, total_registered: agents.length, active_count: result.filter(a => a.liveness === "active").length })`
   - Error handling: catch errors, return `toolError(e.message, "INTERNAL_ERROR")`
3. Import `computeLiveness` from `../utils/liveness.js`, `DEFAULT_LIVENESS_THRESHOLDS` from `../utils/types.js`, `toolResult`/`toolError`/`TwiningError` from `../utils/errors.js`

Create `test/coordination-tools.test.ts` following the `test/tools.test.ts` pattern:
1. Set up temp dir with agent store files in beforeEach
2. Use the `callTool` helper pattern (access `_registeredTools` internal)
3. Test cases:
   - Returns empty array when no agents registered
   - Returns agents with liveness status computed from timestamps
   - Filters out gone agents when include_gone=false
   - Returns all agents including gone when include_gone=true (default)
   - Returns correct total_registered and active_count metrics
   - Handles errors gracefully (returns toolError)
  </action>
  <verify>Run `npx vitest run test/coordination-tools.test.ts` — all tests pass.</verify>
  <done>twining_agents tool registered, returns agent list with liveness, supports include_gone filtering, 6+ tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Extend twining_status with agent counts and wire coordination tools in server.ts</name>
  <files>src/tools/lifecycle-tools.ts, src/server.ts, test/tools.test.ts</files>
  <action>
**Extend lifecycle-tools.ts:**

1. Add `AgentStore` import from `../storage/agent-store.js`
2. Add `computeLiveness` import from `../utils/liveness.js` and `DEFAULT_LIVENESS_THRESHOLDS` from `../utils/types.js`
3. Add `agentStore: AgentStore` as a new parameter to `registerLifecycleTools` (add after `config` parameter, make it optional with default null to avoid breaking existing tests)
4. In the `twining_status` handler, after the existing graph counts section:
   - If agentStore is provided, call `agentStore.getAll()`, compute liveness for each, count total registered and active
   - Add `registered_agents` and `active_agents` fields to the result object
   - If agentStore is null, set both to 0
5. Update the summary string to include agent info: `${registered_agents} registered agents (${active_agents} active)`

**Wire in server.ts:**

1. Add imports: `AgentStore` from `./storage/agent-store.js`, `HandoffStore` from `./storage/handoff-store.js`, `CoordinationEngine` from `./engine/coordination.js`, `registerCoordinationTools` from `./tools/coordination-tools.js`
2. After existing store creation, create: `const agentStore = new AgentStore(twiningDir)` and `const handoffStore = new HandoffStore(twiningDir)`
3. Create: `const coordinationEngine = new CoordinationEngine(agentStore, handoffStore, blackboardEngine, decisionStore, blackboardStore, config)`
4. Update `registerLifecycleTools` call to pass `agentStore` as the new parameter
5. Add: `registerCoordinationTools(server, agentStore, coordinationEngine, config)`

**Extend test/tools.test.ts:**

1. Add AgentStore import
2. Create agentStore in beforeEach (needs agents/ dir and registry.json)
3. Update `registerLifecycleTools` call to include agentStore
4. Add test: "twining_status includes agent counts" — register an agent, verify registered_agents=1, active_agents=1
5. Add test: "twining_status shows 0 counts with no agents" — verify registered_agents=0, active_agents=0
  </action>
  <verify>Run `npx vitest run test/tools.test.ts test/coordination-tools.test.ts` — all tests pass. Run `npx vitest run` — full suite passes (no regressions).</verify>
  <done>`twining_status` returns registered_agents and active_agents counts, server.ts wires AgentStore/HandoffStore/CoordinationEngine and registers coordination tools, all existing tests still pass.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — full test suite passes (419+ tests, no regressions)
2. `npx tsc --noEmit` — no TypeScript errors
3. `twining_agents` tool exists and returns agent data with liveness
4. `twining_status` includes registered_agents and active_agents fields
5. server.ts creates AgentStore, HandoffStore, CoordinationEngine and wires them
</verification>

<success_criteria>
- twining_agents tool returns agents with capabilities and liveness status (DEL-04)
- twining_status includes registered and active agent counts (DEL-05)
- All new tests pass, no regressions in existing tests
- server.ts properly wires new coordination dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/13-tools-and-assembly/13-01-SUMMARY.md`
</output>
